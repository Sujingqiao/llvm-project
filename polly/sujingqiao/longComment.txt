=== 长注释提取报告 ===
根目录: /Users/sujingqiao/Documents/homepage/ENV/myenv/source/polly
最小行数: 4
包含头文件: 是
提取时间: 1756176160.77
找到的长注释块数量: 613

================================================================================

[1] 文件: lib/Exchange/JSONExporter.cpp : 第 95 行
------------------------------------------------------------
Export all arrays from the Scop.

@param S The Scop containing the arrays.

@returns Json::Value containing the arrays.

================================================================================

[2] 文件: lib/Exchange/JSONExporter.cpp : 第 206 行
------------------------------------------------------------
Import a new context from JScop.

@param S The scop to update.
@param JScop The JScop file describing the new schedule.

@returns True if the import succeeded, otherwise False.

================================================================================

[3] 文件: lib/Exchange/JSONExporter.cpp : 第 256 行
------------------------------------------------------------
Import a new schedule from JScop.

... and verify that the new schedule does preserve existing data
dependences.

@param S The scop to update.
@param JScop The JScop file describing the new schedule.
@param D The data dependences of the @p S.

@returns True if the import succeeded, otherwise False.

================================================================================

[4] 文件: lib/Exchange/JSONExporter.cpp : 第 340 行
------------------------------------------------------------
Import new memory accesses from JScop.

@param S The scop to update.
@param JScop The JScop file describing the new schedule.
@param DL The data layout to assume.
@param NewAccessStrings optionally record the imported access strings

@returns True if the import succeeded, otherwise False.

================================================================================

[5] 文件: lib/Exchange/JSONExporter.cpp : 第 593 行
------------------------------------------------------------
Get the accepted primitive type from its textual representation
       @p TypeTextRepresentation.

@param TypeTextRepresentation The textual representation of the type.
@return The pointer to the primitive type, if this type is accepted
        or nullptr otherwise.

================================================================================

[6] 文件: lib/Exchange/JSONExporter.cpp : 第 625 行
------------------------------------------------------------
Import new arrays from JScop.

@param S The scop to update.
@param JScop The JScop file describing new arrays.

@returns True if the import succeeded, otherwise False.

================================================================================

[7] 文件: lib/Exchange/JSONExporter.cpp : 第 687 行
------------------------------------------------------------
Import a Scop from a JSCOP file
@param S The scop to be modified
@param D Dependence Info
@param DL The DataLayout of the function
@param NewAccessStrings Optionally record the imported access strings

@returns true on success, false otherwise. Beware that if this returns
false, the Scop may still have been modified. In this case the Scop contains
invalid information.

================================================================================

[8] 文件: lib/Analysis/ScopDetection.cpp : 第 830 行
------------------------------------------------------------
Remove smax of smax(0, size) expressions from a SCEV expression and
register the '...' components.

Array access expressions as they are generated by GFortran contain smax(0,
size) expressions that confuse the 'normal' delinearization algorithm.
However, if we extract such expressions before the normal delinearization
takes place they can actually help to identify array size expressions in
Fortran accesses. For the subsequently following delinearization the smax(0,
size) component can be replaced by just 'size'. This is correct as we will
always add and verify the assumption that for all subscript expressions
'exp' the inequality 0 <= exp < size holds. Hence, we will also verify
that 0 <= size, which means smax(0, size) == size.

================================================================================

[9] 文件: lib/Analysis/ScopDetection.cpp : 第 1266 行
------------------------------------------------------------
Check whether @p L has exiting blocks.

@param L The loop of interest

@return True if the loop has exiting blocks, false otherwise.

================================================================================

[10] 文件: lib/Analysis/ScopDetection.cpp : 第 1844 行
------------------------------------------------------------
Enum for coloring BBs in Region.

WHITE - Unvisited BB in DFS walk.
GREY - BBs which are currently on the DFS stack for processing.
BLACK - Visited and completely processed BB.

================================================================================

[11] 文件: lib/Analysis/ScopBuilder.cpp : 第 191 行
------------------------------------------------------------
Create a map to map from a given iteration to a subsequent iteration.

This map maps from SetSpace -> SetSpace where the dimensions @p Dim
is incremented by one and all other dimensions are equal, e.g.,
            [i0, i1, i2, i3] -> [i0, i1, i2 + 1, i3]

if @p Dim is 2 and @p SetSpace has 4 dimensions.

================================================================================

[12] 文件: lib/Analysis/ScopBuilder.cpp : 第 223 行
------------------------------------------------------------
Compute the (un)bounded parts of @p S wrt. to dimension @p Dim.

@returns A separation of @p S into first an unbounded then a bounded subset,
         both with regards to the dimension @p Dim.

================================================================================

[13] 文件: lib/Analysis/ScopBuilder.cpp : 第 335 行
------------------------------------------------------------
Compute the isl representation for the SCEV @p E in this BB.

@param BB               The BB for which isl representation is to be
computed.
@param InvalidDomainMap A map of BB to their invalid domains.
@param E                The SCEV that should be translated.
@param NonNegative      Flag to indicate the @p E has to be non-negative.

Note that this function will also adjust the invalid context accordingly.

================================================================================

[14] 文件: lib/Analysis/ScopBuilder.cpp : 第 354 行
------------------------------------------------------------
Build condition sets for unsigned ICmpInst(s).
Special handling is required for unsigned operands to ensure that if
MSB (aka the Sign bit) is set for an operands in an unsigned ICmpInst
it should wrap around.

@param IsStrictUpperBound holds information on the predicate relation
between TestVal and UpperBound, i.e,
TestVal < UpperBound  OR  TestVal <= UpperBound

================================================================================

[15] 文件: lib/Analysis/ScopBuilder.cpp : 第 1186 行
------------------------------------------------------------
To generate a schedule for the elements in a Region we traverse the Region
in reverse-post-order and add the contained RegionNodes in traversal order
to the schedule of the loop that is currently at the top of the LoopStack.
For loop-free codes, this results in a correct sequential ordering.

Example:
          bb1(0)
        /     \.
     bb2(1)   bb3(2)
        \    /  \.
         bb4(3)  bb5(4)
            \   /
             bb6(5)

Including loops requires additional processing. Whenever a loop header is
encountered, the corresponding loop is added to the @p LoopStack. Starting
from an empty schedule, we first process all RegionNodes that are within
this loop and complete the sequential schedule at this loop-level before
processing about any other nodes. To implement this
loop-nodes-first-processing, the reverse post-order traversal is
insufficient. Hence, we additionally check if the traversal yields
sub-regions or blocks that are outside the last loop on the @p LoopStack.
These region-nodes are then queue and only traverse after the all nodes
within the current loop have been processed.

================================================================================

[16] 文件: lib/Analysis/ScopBuilder.cpp : 第 1299 行
------------------------------------------------------------
If any of the loops has a disable_nonforced heuristic, mark the
entire SCoP as such. The ISL rescheduler can only reschedule the
SCoP in its entirety.
TODO: ScopDetection could avoid including such loops or warp them as
boxed loop. It still needs to pass-through loop with user-defined
metadata.

================================================================================

[17] 文件: lib/Analysis/ScopBuilder.cpp : 第 1781 行
------------------------------------------------------------
Generate a name for a statement.

@param BB     The basic block the statement will represent.
@param BBIdx  The index of the @p BB relative to other BBs/regions.
@param Count  The index of the created statement in @p BB.
@param IsMain Whether this is the main of all statement for @p BB. If true,
              no suffix will be added.
@param IsLast Uses a special indicator for the last statement of a BB.

================================================================================

[18] 文件: lib/Analysis/ScopBuilder.cpp : 第 1805 行
------------------------------------------------------------
Generate a name for a statement that represents a non-affine subregion.

@param R    The region the statement will represent.
@param RIdx The index of the @p R relative to other BBs/regions.

================================================================================

[19] 文件: lib/Analysis/ScopBuilder.cpp : 第 1836 行
------------------------------------------------------------
Is @p Inst an ordered instruction?

An unordered instruction is an instruction, such that a sequence of
unordered instructions can be permuted without changing semantics. Any
instruction for which this is not always the case is ordered.

================================================================================

[20] 文件: lib/Analysis/ScopBuilder.cpp : 第 1867 行
------------------------------------------------------------
Ensure that the order of ordered instructions does not change.

If we encounter an ordered instruction enclosed in instructions belonging to
a different statement (which might as well contain ordered instructions, but
this is not tested here), join them.

================================================================================

[21] 文件: lib/Analysis/ScopBuilder.cpp : 第 1906 行
------------------------------------------------------------
If the BasicBlock has an edge from itself, ensure that the PHI WRITEs for
the incoming values from this block are executed after the PHI READ.

Otherwise it could overwrite the incoming value from before the BB with the
value for the next execution. This can happen if the PHI WRITE is added to
the statement with the instruction that defines the incoming value (instead
of the last statement of the same BB). To ensure that the PHI READ and WRITE
are in order, we put both into the statement. PHI WRITEs are always executed
after PHI READs when they are in the same statement.

TODO: This is an overpessimization. We only have to ensure that the PHI
WRITE is not put into a statement containing the PHI itself. That could also
be done by
- having all (strongly connected) PHIs in a single statement,
- unite only the PHIs in the operand tree of the PHI WRITE (because it only
  has a chance of being lifted before a PHI by being in a statement with a
  PHI that comes before in the basic block), or
- when uniting statements, ensure that no (relevant) PHIs are overtaken.

================================================================================

[22] 文件: lib/Analysis/ScopBuilder.cpp : 第 2818 行
------------------------------------------------------------
Check if an access range is too complex.

An access range is too complex, if it contains either many disjuncts or
very complex expressions. As a simple heuristic, we assume if a set to
be too complex if the sum of existentially quantified dimensions and
set dimensions is larger than a threshold. This reliably detects both
sets with many disjuncts as well as sets with many divisions as they
arise in h264.

@param AccessRange The range to check for complexity.

@returns True if the access range is too complex.

================================================================================

[23] 文件: lib/Analysis/ScopBuilder.cpp : 第 3133 行
------------------------------------------------------------
Find the canonical scop array info object for a set of invariant load
hoisted loads. The canonical array is the one that corresponds to the
first load in the list of accesses which is used as base pointer of a
scop array.

================================================================================

[24] 文件: lib/Analysis/ScopBuilder.cpp : 第 3242 行
------------------------------------------------------------
Add the minimal/maximal access in @p Set to @p User.

@return True if more accesses should be added, false if we reached the
        maximal number of run-time checks to be generated.

================================================================================

[25] 文件: lib/Analysis/ScopBuilder.cpp : 第 3554 行
------------------------------------------------------------
Check the consistency of every statement's MemoryAccesses.

The check is carried out by expecting the "physical" kind of use (derived
from the BasicBlocks instructions resides in) to be same as the "virtual"
kind of use (derived from a statement's MemoryAccess).

The "physical" uses are taken by ensureValueRead to determine whether to
create MemoryAccesses. When done, the kind of scalar access should be the
same no matter which way it was derived.

The MemoryAccesses might be changed by later SCoP-modifying passes and hence
can intentionally influence on the kind of uses (not corresponding to the
"physical" anymore, hence called "virtual"). The CodeGenerator therefore has
to pick up the virtual uses. But here in the code generator, this has not
happened yet, such that virtual and physical uses are equivalent.

================================================================================

[26] 文件: lib/Analysis/DependenceInfo.cpp : 第 197 行
------------------------------------------------------------
Compute the privatization dependences for a given dependency @p Map

Privatization dependences are widened original dependences which originate
or end in a reduction access. To compute them we apply the transitive close
of the reduction dependences (which maps each iteration of a reduction
statement to all following ones) on the RAW/WAR/WAW dependences. The
dependences which start or end at a reduction statement will be extended to
depend on all following reduction statement iterations as well.
Note: "Following" here means according to the reduction dependences.

For the input:

 S0:   *sum = 0;
       for (int i = 0; i < 1024; i++)
 S1:     *sum += i;
 S2:   *sum = *sum * 3;

we have the following dependences before we add privatization dependences:

  RAW:
    { S0[] -> S1[0]; S1[1023] -> S2[] }
  WAR:
    {  }
  WAW:
    { S0[] -> S1[0]; S1[1024] -> S2[] }
  RED:
    { S1[i0] -> S1[1 + i0] : i0 >= 0 and i0 <= 1022 }

and afterwards:

  RAW:
    { S0[] -> S1[i0] : i0 >= 0 and i0 <= 1023;
      S1[i0] -> S2[] : i0 >= 0 and i0 <= 1023}
  WAR:
    {  }
  WAW:
    { S0[] -> S1[i0] : i0 >= 0 and i0 <= 1023;
      S1[i0] -> S2[] : i0 >= 0 and i0 <= 1023}
  RED:
    { S1[i0] -> S1[1 + i0] : i0 >= 0 and i0 <= 1022 }

Note: This function also computes the (reverse) transitive closure of the
      reduction dependences.

================================================================================

[27] 文件: lib/CodeGen/IRBuilder.cpp : 第 25 行
------------------------------------------------------------
Get a self referencing id metadata node.

The MDNode looks like this (if arg0/arg1 are not null):

   '!n = distinct !{!n, arg0, arg1}'

@return The self referencing id metadata node.

================================================================================

[28] 文件: lib/CodeGen/IRBuilder.cpp : 第 185 行
------------------------------------------------------------
Get the pointer operand

@param Inst The instruction to be analyzed.
@return the pointer operand in case @p Inst is a memory access
        instruction and nullptr otherwise.

================================================================================

[29] 文件: lib/CodeGen/IRBuilder.cpp : 第 198 行
------------------------------------------------------------
Find the base pointer of an array access.

This should be equivalent to ScalarEvolution::getPointerBase, which we
cannot use here the IR is still under construction which ScalarEvolution
assumes to not be modified.

================================================================================

[30] 文件: lib/CodeGen/IslAst.cpp : 第 191 行
------------------------------------------------------------
Check if the current scheduling dimension is parallel.

In case the dimension is parallel we also check if any reduction
dependences is broken when we exploit this parallelism. If so,
@p IsReductionParallel will be set to true. The reduction dependences we use
to check are actually the union of the transitive closure of the initial
reduction dependences together with their reversal. Even though these
dependences connect all iterations with each other (thus they are cyclic)
we can perform the parallelism check as we are only interested in a zero
(or non-zero) dependence distance on the dimension in question.

================================================================================

[31] 文件: lib/CodeGen/IslAst.cpp : 第 438 行
------------------------------------------------------------
Simple cost analysis for a given SCoP.

TODO: Improve this analysis and extract it to make it usable in other
      places too.
      In order to improve the cost model we could either keep track of
      performed optimizations (e.g., tiling) or compute properties on the
      original as well as optimized SCoP (e.g., #stride-one-accesses).

================================================================================

[32] 文件: lib/CodeGen/CodeGeneration.cpp : 第 75 行
------------------------------------------------------------
Mark a basic block unreachable.

Marks the basic block @p Block unreachable by equipping it with an
UnreachableInst.

================================================================================

[33] 文件: lib/CodeGen/CodeGeneration.cpp : 第 117 行
------------------------------------------------------------
Remove all lifetime markers (llvm.lifetime.start, llvm.lifetime.end) from
@R.

CodeGeneration does not copy lifetime markers into the optimized SCoP,
which would leave the them only in the original path. This can transform
code such as

    llvm.lifetime.start(%p)
    llvm.lifetime.end(%p)

into

    if (RTC) {
      // generated code
    } else {
      // original code
      llvm.lifetime.start(%p)
    }
    llvm.lifetime.end(%p)

The current StackColoring algorithm cannot handle if some, but not all,
paths from the end marker to the entry block cross the start marker. Same
for start markers that do not always cross the end markers. We avoid any
issues by removing all lifetime markers, even from the original code.

A better solution could be to hoist all llvm.lifetime.start to the split
node and all llvm.lifetime.end to the merge node, which should be
conservatively correct.

================================================================================

[34] 文件: lib/CodeGen/IslNodeBuilder.cpp : 第 279 行
------------------------------------------------------------
Extract the out-of-scop values and SCEVs referenced from a set describing
a ScopStmt.

This includes the SCEVUnknowns referenced by the SCEVs used in the
statement and the base pointers of the memory accesses. For scalar
statements we force the generation of alloca memory locations and list
these locations in the set of out-of-scop values as well.

@param Set     A set which references the ScopStmt we are interested in.
@param UserPtr A void pointer that can be casted to a SubtreeReferences
               structure.

================================================================================

[35] 文件: lib/CodeGen/IslNodeBuilder.cpp : 第 296 行
------------------------------------------------------------
Extract the out-of-scop values and SCEVs referenced from a union set
referencing multiple ScopStmts.

This includes the SCEVUnknowns referenced by the SCEVs used in the
statement and the base pointers of the memory accesses. For scalar
statements we force the generation of alloca memory locations and list
these locations in the set of out-of-scop values as well.

@param USet       A union set referencing the ScopStmts we are interested
                  in.
@param References The SubtreeReferences data structure through which
                  results are returned and further information is
                  provided.

================================================================================

[36] 文件: lib/CodeGen/IslNodeBuilder.cpp : 第 344 行
------------------------------------------------------------
Note: Code generation of induction variables of loops outside Scops

Remove loops that contain the scop or that are part of the scop, as they
are considered local. This leaves only loops that are before the scop, but
do not contain the scop itself.
We ignore loops perfectly contained in the Scop because these are already
generated at `IslNodeBuilder::addParameters`. These `Loops` are loops
whose induction variables are referred to by the Scop, but the Scop is not
fully contained in these Loops. Since there can be many of these,
we choose to codegen these on-demand.
@see IslNodeBuilder::materializeNonScopLoopInductionVariable.

================================================================================

[37] 文件: lib/CodeGen/IslNodeBuilder.cpp : 第 415 行
------------------------------------------------------------
Restore the initial ordering of dimensions of the band node

In case the band node represents all the dimensions of the iteration
domain, recreate the band node to restore the initial ordering of the
dimensions.

@param Node The band node to be modified.
@return The modified schedule node.

================================================================================

[38] 文件: lib/CodeGen/IslNodeBuilder.cpp : 第 1391 行
------------------------------------------------------------
We pass the insert location of our Builder, as Polly ensures during IR
generation that there is always a valid CFG into which instructions are
inserted. As a result, the insertpoint is known to be always followed by a
terminator instruction. This means the insert point may be specified by a
terminator instruction, but it can never point to an ->end() iterator
which does not have a corresponding instruction. Hence, dereferencing
the insertpoint to obtain an instruction is known to be save.

We also do not need to update the Builder here, as new instructions are
always inserted _before_ the given InsertLocation. As a result, the
insert location remains valid.

================================================================================

[39] 文件: lib/CodeGen/IslNodeBuilder.cpp : 第 1412 行
------------------------------------------------------------
The AST expression we generate to perform the run-time check assumes
computations on integer types of infinite size. As we only use 64-bit
arithmetic we check for overflows, in case of which we set the result
of this run-time check to false to be conservatively correct,

================================================================================

[40] 文件: lib/Support/ISLTools.cpp : 第 23 行
------------------------------------------------------------
Create a map that shifts one dimension by an offset.

Example:
makeShiftDimAff({ [i0, i1] -> [o0, o1] }, 1, -2)
  = { [i0, i1] -> [i0, i1 - 1] }

@param Space  The map space of the result. Must have equal number of in- and
              out-dimensions.
@param Pos    Position to shift.
@param Amount Value added to the shifted dimension.

@return An isl_multi_aff for the map with this shifted dimension.

================================================================================

[41] 文件: lib/Support/ISLTools.cpp : 第 44 行
------------------------------------------------------------
Construct a map that swaps two nested tuples.

@param FromSpace1 { Space1[] }
@param FromSpace2 { Space2[] }

@return { [Space1[] -> Space2[]] -> [Space2[] -> Space1[]] }

================================================================================

[42] 文件: lib/Support/ISLTools.cpp : 第 616 行
------------------------------------------------------------
Determine the sorting order of the sets @p A and @p B without considering
the space structure.

Ordering is based on the lower bounds of the set's dimensions. First
dimensions are considered first.

================================================================================

[43] 文件: lib/Support/ISLTools.cpp : 第 673 行
------------------------------------------------------------
Compare the sets @p A and @p B according to their nested space structure.
Returns 0 if the structure is considered equal.
If @p ConsiderTupleLen is false, the number of dimensions in a tuple are
ignored, i.e. a tuple with the same name but different number of dimensions
are considered equal.

================================================================================

[44] 文件: lib/Support/ISLTools.cpp : 第 738 行
------------------------------------------------------------
Print a string representation of @p USet to @p OS.

The pieces of @p USet are printed in a sorted order. Spaces with equal or
similar nesting structure are printed together. Compared to isl's own
printing function the uses the structure itself as base of the sorting, not
a hash of it. It ensures that e.g. maps spaces with same domain structure
are printed together. Set pieces with same structure are printed in order of
their lower bounds.

@param USet     Polyhedra to print.
@param OS       Target stream.
@param Simplify Whether to simplify the polyhedron before printing.
@param IsMap    Whether @p USet is a wrapped map. If true, sets are
                unwrapped before printing to again appear as a map.

================================================================================

[45] 文件: lib/Support/ISLTools.cpp : 第 829 行
------------------------------------------------------------
Make each point of a set explicit.

"Expanding" makes each point a set contains explicit. That is, the result is
a set of singleton polyhedra. Unbounded dimensions are not expanded.

Example:
  { [i] : 0 <= i < 2 }
is expanded to:
  { [0]; [1] }

================================================================================

[46] 文件: lib/Support/VirtualInstruction.cpp : 第 220 行
------------------------------------------------------------
Add non-removable memory accesses in @p Stmt to @p RootInsts.

@param Local If true, all writes are assumed to escape. markAndSweep
algorithms can use this to be applicable to a single ScopStmt only without
the risk of removing definitions required by other statements.
             If false, only writes for SCoP-escaping values are roots.  This
             is global mode, where such writes must be marked by theirs uses
             in order to be reachable.

================================================================================

[47] 文件: lib/Support/VirtualInstruction.cpp : 第 264 行
------------------------------------------------------------
Mark accesses and instructions as used if they are reachable from a root,
walking the operand trees.

@param S              The SCoP to walk.
@param LI             The LoopInfo Analysis.
@param RootInsts      List of root instructions.
@param RootAccs       List of root accesses.
@param UsesInsts[out] Receives all reachable instructions, including the
roots.
@param UsedAccs[out]  Receives all reachable accesses, including the roots.
@param OnlyLocal      If non-nullptr, restricts walking to a single
statement.

================================================================================

[48] 文件: lib/Support/ScopHelper.cpp : 第 231 行
------------------------------------------------------------
ScopExpander generates IR the the value of a SCEV that represents a value
from a SCoP.

IMPORTANT: There are two ScalarEvolutions at play here. First, the SE that
was used to analyze the original SCoP (not actually referenced anywhere
here, but passed as argument to make the distinction clear). Second, GenSE
which is the SE for the function that the code is emitted into. SE and GenSE
may be different when the generated code is to be emitted into an outlined
function, e.g. for a parallel loop. That is, each SCEV is to be used only by
the SE that "owns" it and ScopExpander handles the translation between them.
The SCEVVisitor methods are only to be called on SCEVs of the original SE.
Their job is to create a new SCEV for GenSE. The nested SCEVExpander is to
be used only with SCEVs belonging to GenSE. Currently SCEVs do not store a
reference to the ScalarEvolution they belong to, so a mixup does not
immediately cause a crash but certainly is a violation of its interface.

The SCEVExpander will __not__ generate any code for an existing SDiv/SRem
instruction but just use it, if it is referenced as a SCEVUnknown. We want
however to generate new code if the instruction is in the analyzed region
and we generate code outside/in front of that region. Hence, we generate the
code for the SDiv/SRem operands in front of the analyzed region and then
create a new SDiv/SRem operation there too.

================================================================================

[49] 文件: lib/Support/ScopHelper.cpp : 第 376 行
------------------------------------------------------------
The following functions will just traverse the SCEV and rebuild it using
GenSE and the new operands returned by the traversal.

{

================================================================================

[50] 文件: lib/Support/RegisterPasses.cpp : 第 203 行
------------------------------------------------------------
Initialize Polly passes when library is loaded.

We use the constructor of a statically declared object to initialize the
different Polly passes right after the Polly library is loaded. This ensures
that the Polly passes are available e.g. in the 'opt' tool.

================================================================================

[51] 文件: lib/Support/RegisterPasses.cpp : 第 268 行
------------------------------------------------------------
Register Polly passes such that they form a polyhedral optimizer.

The individual Polly passes are registered in the pass manager such that
they form a full polyhedral optimizer. The flow of the optimizer starts with
a set of preparing transformations that canonicalize the LLVM-IR such that
the LLVM-IR is easier for us to understand and to optimizes. On the
canonicalized LLVM-IR we first run the ScopDetection pass, which detects
static control flow regions. Those regions are then translated by the
ScopInfo pass into a polyhedral representation. As a next step, a scheduling
optimizer is run on the polyhedral representation and finally the optimized
polyhedral representation is code generated back to LLVM-IR.

Besides this core functionality, we optionally schedule passes that provide
a graphical view of the scops (Polly[Only]Viewer, Polly[Only]Printer), that
allow the export/import of the polyhedral representation
(JSCON[Exporter|Importer]) or that show the cfg after code generation.

For certain parts of the Polly optimizer, several alternatives are provided:

As scheduling optimizer we support the isl scheduling optimizer
(http://freecode.com/projects/isl).
It is also possible to run Polly with no optimizer. This mode is mainly
provided to analyze the run and compile time changes caused by the
scheduling optimizer.

Polly supports the isl internal code generator.

================================================================================

[52] 文件: lib/Support/RegisterPasses.cpp : 第 295 行
------------------------------------------------------------
Add the pass sequence required for Polly to the New Pass Manager.

@param PM           The pass manager itself.
@param Level        The optimization level. Used for the cleanup of Polly's
                    output.
@param EnableForOpt Whether to add Polly IR transformations. If False, only
                    the analysis passes are added, skipping Polly itself.
                    The IR may still be modified.

================================================================================

[53] 文件: lib/Support/RegisterPasses.cpp : 第 567 行
------------------------------------------------------------
Register Polly to be available as an optimizer


We can currently run Polly at two different points int the pass manager.
a) very early, b) right before the vectorizer.

The default is currently a), to register Polly such that it runs as early as
possible. This has several implications:

  1) We need to schedule more canonicalization passes

  As nothing is run before Polly, it is necessary to run a set of preparing
  transformations before Polly to canonicalize the LLVM-IR and to allow
  Polly to detect and understand the code.

  2) We get the full -O3 optimization sequence after Polly

  The LLVM-IR that is generated by Polly has been optimized on a high level,
  but it may be rather inefficient on the lower/scalar level. By scheduling
  Polly before all other passes, we have the full sequence of -O3
  optimizations behind us, such that inefficiencies on the low level can
  be optimized away.

We are currently evaluating the benefit or running Polly at b). b) is nice
as everything is fully inlined and canonicalized, but we need to be able to
handle LICMed code to make it useful.

================================================================================

[54] 文件: lib/Support/SCEVValidator.cpp : 第 16 行
------------------------------------------------------------
The type of a SCEV

To check for the validity of a SCEV we assign to each SCEV a type. The
possible types are INT, PARAM, IV and INVALID. The order of the types is
important. The subexpressions of SCEV with a type X can only have a type
that is smaller or equal than X.

================================================================================

[55] 文件: lib/Support/SCEVValidator.cpp : 第 89 行
------------------------------------------------------------
Merge a result.

This means to merge the parameters and to set the Type to the most
specific Type that matches both.

================================================================================

[56] 文件: lib/Transform/FlattenAlgo.cpp : 第 39 行
------------------------------------------------------------
Whether a dimension of a set is (lower and upper) bounded by a constant or
parameters, i.e. there are two expressions Min_p and Max_p of the parameters
p, such that every value x of the chosen dimensions is
Min_p <= x <= Max_p.

================================================================================

[57] 文件: lib/Transform/FlattenAlgo.cpp : 第 112 行
------------------------------------------------------------
Remove @p n dimensions from @p UMap's range, starting at @p first.

It is assumed that all maps in the maps have at least the necessary number
of out dimensions.

================================================================================

[58] 文件: lib/Transform/FlattenAlgo.cpp : 第 146 行
------------------------------------------------------------
Flatten a sequence-like first dimension.

A sequence-like scatter dimension is constant, or at least only small
variation, typically the result of ordering a sequence of different
statements. An example would be:
  { Stmt_A[] -> [0, X, ...]; Stmt_B[] -> [1, Y, ...] }
to schedule all instances of Stmt_A before any instance of Stmt_B.

To flatten, first begin with an offset of zero. Then determine the lowest
possible value of the dimension, call it "i" [In the example we start at 0].
Considering only schedules with that value, consider only instances with
that value and determine the extent of the next dimension. Let l_X(i) and
u_X(i) its minimum (lower bound) and maximum (upper bound) value. Add them
as "Offset + X - l_X(i)" to the new schedule, then add "u_X(i) - l_X(i) + 1"
to Offset and remove all i-instances from the old schedule. Repeat with the
remaining lowest value i' until there are no instances in the old schedule
left.
The example schedule would be transformed to:
  { Stmt_X[] -> [X - l_X, ...]; Stmt_B -> [l_X - u_X + 1 + Y - l_Y, ...] }

================================================================================

[59] 文件: lib/Transform/FlattenAlgo.cpp : 第 245 行
------------------------------------------------------------
Flatten a loop-like first dimension.

A loop-like dimension is one that depends on a variable (usually a loop's
induction variable). Let the input schedule look like this:
  { Stmt[i] -> [i, X, ...] }

To flatten, we determine the largest extent of X which may not depend on the
actual value of i. Let l_X() the smallest possible value of X and u_X() its
largest value. Then, construct a new schedule
  { Stmt[i] -> [i * (u_X() - l_X() + 1), ...] }

================================================================================

[60] 文件: lib/Transform/Simplify.cpp : 第 38 行
------------------------------------------------------------
Number of max disjuncts we allow in removeOverwrites(). This is to avoid
that the analysis of accesses in a statement is becoming too complex. Chosen
to be relatively small because all the common cases should access only few
array elements per statement.

================================================================================

[61] 文件: lib/Transform/Simplify.cpp : 第 86 行
------------------------------------------------------------
Like isl::union_map::unite, but may also return an underapproximated
result if getting too complex.

This is implemented by adding disjuncts to the results until the limit is
reached.

================================================================================

[62] 文件: lib/Transform/Simplify.cpp : 第 157 行
------------------------------------------------------------
Remove statements that are never executed due to their domains being
empty.

In contrast to Scop::simplifySCoP, this removes based on the SCoP's
effective domain, i.e. including the SCoP's context as used by some other
simplification methods in this pass. This is necessary because the
analysis on empty domains is unreliable, e.g. remove a scalar value
definition MemoryAccesses, but not its use.

================================================================================

[63] 文件: lib/Transform/Simplify.cpp : 第 167 行
------------------------------------------------------------
Remove writes that are overwritten unconditionally later in the same
statement.

There must be no read of the same value between the write (that is to be
removed) and the overwrite.

================================================================================

[64] 文件: lib/Transform/Simplify.cpp : 第 174 行
------------------------------------------------------------
Combine writes that write the same value if possible.

This function is able to combine:
- Partial writes with disjoint domain.
- Writes that write to the same array element.

In all cases, both writes must write the same values.

================================================================================

[65] 文件: lib/Transform/Simplify.cpp : 第 222 行
------------------------------------------------------------
Remove statements that are never executed due to their domains being
empty.

In contrast to Scop::simplifySCoP, this removes based on the SCoP's
effective domain, i.e. including the SCoP's context as used by some other
simplification methods in this pass. This is necessary because the
analysis on empty domains is unreliable, e.g. remove a scalar value
definition MemoryAccesses, but not its use.

================================================================================

[66] 文件: lib/Transform/Simplify.cpp : 第 246 行
------------------------------------------------------------
Remove writes that are overwritten unconditionally later in the same
statement.

There must be no read of the same value between the write (that is to be
removed) and the overwrite.

================================================================================

[67] 文件: lib/Transform/Simplify.cpp : 第 302 行
------------------------------------------------------------
Combine writes that write the same value if possible.

This function is able to combine:
- Partial writes with disjoint domain.
- Writes that write to the same array element.

In all cases, both writes must write the same values.

================================================================================

[68] 文件: lib/Transform/MatmulOptimizer.cpp : 第 151 行
------------------------------------------------------------
Parameters of the micro kernel.

Parameters, which determine sizes of rank-1 (i.e., outer product) update
used in the optimized matrix multiplication.

================================================================================

[69] 文件: lib/Transform/MatmulOptimizer.cpp : 第 160 行
------------------------------------------------------------
Parameters of the macro kernel.

Parameters, which determine sizes of blocks of partitioned matrices
used in the optimized matrix multiplication.

================================================================================

[70] 文件: lib/Transform/MatmulOptimizer.cpp : 第 170 行
------------------------------------------------------------
Parameters of the matrix multiplication operands.

Parameters, which describe access relations that represent operands of the
matrix multiplication.

================================================================================

[71] 文件: lib/Transform/MatmulOptimizer.cpp : 第 184 行
------------------------------------------------------------
Parameters of the tensor contraction operands.

A general d-dimensional tensor T ∈ R ^ Nu0 x ... x Nud−1 can be defined
as the set of scalar elements indexed by the set of indices u0 ... ud,

T ≡ {Anu0...nud−1 ∈ R | (u0,...,ud−1) ∈ Nu0 x ... x Nud−1}.

Let A, B, and C be dA, dB, and dC-dimensional tensors, respectively.
Let the free and the contracted indices of the tensor A be grouped into
two bundles I = i0...ir−1 and P = p0...pt−1, respectively. Similarly,
the free and the contracted indices of B are grouped into bundles
J = j0..js−1 and P and the free indices of C are grouped into
bundles I and J.

Tensor contraction (TC) of tensors A, B into tensor C can be represented as
C(shuffle(I,J))=∑α·A(shuffle(I,P))·B(shuffle(P,J))+β·C(shuffle(I,J)),
where ∑ is a summation over all contracted indices of P,
α, β ∈ R, Npi is the length of the tensor dimension that corresponds
to the index pi, A(shuffle(I, P)), B(shuffle(P, J)), C(shuffle(I, J)) are
accesses to tensors A, B, C, respectively,
shuffle(I, J), shuffle(I, P), and shuffle(P, J) are permutations of
the enclosed indices.

Multiplication of C(shuffle(I,J)) by β can be moved into a different SCoP
statement by loop distribution, which is done by the isl scheduler.

================================================================================

[72] 文件: lib/Transform/MatmulOptimizer.cpp : 第 210 行
------------------------------------------------------------
such a transformation.

TCInfoTy contains parameters, which describe access relations that represent
operands of the tensor contraction.

================================================================================

[73] 文件: lib/Transform/MatmulOptimizer.cpp : 第 240 行
------------------------------------------------------------
@{
Sizes of tensor dimensions for corresponding input dimensions of
the schedule space. The size of the tensor dimension can be larger than
the size of the corresponding input dimension of the schedule space.
This does not correspond to a tensor contraction. However, such a pattern
will be optimized by the transformation.

================================================================================

[74] 文件: lib/Transform/MatmulOptimizer.cpp : 第 261 行
------------------------------------------------------------
Create an isl::union_set, which describes the option of the form
[isolate[] -> unroll[x]].

@param Ctx An isl::ctx, which is used to create the isl::union_set.

================================================================================

[75] 文件: lib/Transform/MatmulOptimizer.cpp : 第 277 行
------------------------------------------------------------
Permute the two dimensions of the isl map.

Permute @p DstPos and @p SrcPos dimensions of the isl map @p Map that
have type @p DimType.

@param Map     The isl map to be modified.
@param DimType The type of the dimensions.
@param DstPos  The first dimension.
@param SrcPos  The second dimension.
@return        The modified map.

================================================================================

[76] 文件: lib/Transform/MatmulOptimizer.cpp : 第 313 行
------------------------------------------------------------
Check the form of the access relation.

Check that the access relation @p AccMap has the form M[i][j], where i
is a @p FirstPos and j is a @p SecondPos.

@param AccMap    The access relation to be checked.
@param FirstPos  The index of the input dimension that is mapped to
                 the first output dimension.
@param SecondPos The index of the input dimension that is mapped to the
                 second output dimension.
@return          True in case @p AccMap has the expected form and false,
                 otherwise.

================================================================================

[77] 文件: lib/Transform/MatmulOptimizer.cpp : 第 369 行
------------------------------------------------------------
Does the memory access represent a non-scalar operand of the matrix
multiplication.

Check that the memory access @p MemAccess is the read access to a non-scalar
operand of the matrix multiplication or its result.

@param MemAccess The memory access to be checked.
@param MMI       Parameters of the matrix multiplication operands.
@return          True in case the memory access represents the read access
                 to a non-scalar operand of the matrix multiplication and
                 false, otherwise.

================================================================================

[78] 文件: lib/Transform/MatmulOptimizer.cpp : 第 401 行
------------------------------------------------------------
Check accesses to operands of the matrix multiplication.

Check that accesses of the SCoP statement, which corresponds to
the partial schedule @p PartialSchedule, are scalar in terms of loops
containing the matrix multiplication, in case they do not represent
accesses to the non-scalar operands of the matrix multiplication or
its result.

@param  PartialSchedule The partial schedule of the SCoP statement.
@param  MMI             Parameters of the matrix multiplication operands.
@return                 True in case the corresponding SCoP statement
                        represents matrix multiplication and false,
                        otherwise.

================================================================================

[79] 文件: lib/Transform/MatmulOptimizer.cpp : 第 441 行
------------------------------------------------------------
Check for dependencies corresponding to the matrix multiplication.

Check that there is only true dependence of the form
S(..., k, ...) -> S(..., k + 1, …), where S is the SCoP statement
represented by @p Schedule and k is @p Pos. Such a dependence corresponds
to the dependency produced by the matrix multiplication.

@param  Schedule The schedule of the SCoP statement.
@param  D The SCoP dependencies.
@param  Pos The parameter to describe an acceptable true dependence.
            In case it has a negative value, try to determine its
            acceptable value.
@return True in case dependencies correspond to the matrix multiplication
        and false, otherwise.

================================================================================

[80] 文件: lib/Transform/MatmulOptimizer.cpp : 第 476 行
------------------------------------------------------------
Check if the SCoP statement could probably be optimized with analytical
modeling.

containsMatrMult tries to determine whether the following conditions
are true:
1. The last memory access modeling an array, MA1, represents writing to
   memory and has the form S(..., i1, ..., i2, ...) -> M(i1, i2) or
   S(..., i2, ..., i1, ...) -> M(i1, i2), where S is the SCoP statement
   under consideration.
2. There is only one loop-carried true dependency, and it has the
   form S(..., i3, ...) -> S(..., i3 + 1, ...), and there are no
   loop-carried or anti dependencies.
3. SCoP contains three access relations, MA2, MA3, and MA4 that represent
   reading from memory and have the form S(..., i3, ...) -> M(i1, i3),
   S(..., i3, ...) -> M(i3, i2), S(...) -> M(i1, i2), respectively,
   and all memory accesses of the SCoP that are different from MA1, MA2,
   MA3, and MA4 have stride 0, if the innermost loop is exchanged with any
   of loops i1, i2 and i3.

@param PartialSchedule The PartialSchedule that contains a SCoP statement
       to check.
@D     The SCoP dependencies.
@MMI   Parameters of the matrix multiplication operands.

================================================================================

[81] 文件: lib/Transform/MatmulOptimizer.cpp : 第 531 行
------------------------------------------------------------
Permute two dimensions of the band node.

Permute FirstDim and SecondDim dimensions of the Node.

@param Node The band node to be modified.
@param FirstDim The first dimension to be permuted.
@param SecondDim The second dimension to be permuted.

================================================================================

[82] 文件: lib/Transform/MatmulOptimizer.cpp : 第 565 行
------------------------------------------------------------
Create the BLIS macro-kernel.

We create the BLIS macro-kernel by applying a combination of tiling
of dimensions of the band node and interchanging of two innermost
modified dimensions. The values of MacroKernelParams's fields are used
as tile sizes.

@param Node The schedule node to be modified.
@param MacroKernelParams Parameters of the macro kernel
                         to be used as tile sizes.

================================================================================

[83] 文件: lib/Transform/MatmulOptimizer.cpp : 第 595 行
------------------------------------------------------------
Get the size of the widest type of the matrix multiplication operands
in bytes, including alignment padding.

@param MMI Parameters of the matrix multiplication operands.
@return The size of the widest type of the matrix multiplication operands
        in bytes, including alignment padding.

================================================================================

[84] 文件: lib/Transform/MatmulOptimizer.cpp : 第 610 行
------------------------------------------------------------
Get the size of the widest type of the matrix multiplication operands
in bits.

@param MMI Parameters of the matrix multiplication operands.
@return The size of the widest type of the matrix multiplication operands
        in bits.

================================================================================

[85] 文件: lib/Transform/MatmulOptimizer.cpp : 第 625 行
------------------------------------------------------------
Get parameters of the BLIS micro kernel.

We choose the Mr and Nr parameters of the micro kernel to be large enough
such that no stalls caused by the combination of latencies and dependencies
are introduced during the updates of the resulting matrix of the matrix
multiplication. However, they should also be as small as possible to
release more registers for entries of multiplied matrices.

@param TTI Target Transform Info.
@param MMI Parameters of the matrix multiplication operands.
@return The structure of type MicroKernelParamsTy.
@see MicroKernelParamsTy

================================================================================

[86] 文件: lib/Transform/MatmulOptimizer.cpp : 第 697 行
------------------------------------------------------------
Get parameters of the BLIS macro kernel.

During the computation of matrix multiplication, blocks of partitioned
matrices are mapped to different layers of the memory hierarchy.
To optimize data reuse, blocks should be ideally kept in cache between
iterations. Since parameters of the macro kernel determine sizes of these
blocks, there are upper and lower bounds on these parameters.

@param TTI Target Transform Info.
@param MicroKernelParams Parameters of the micro-kernel
                         to be taken into account.
@param MMI Parameters of the matrix multiplication operands.
@return The structure of type MacroKernelParamsTy.
@see MacroKernelParamsTy
@see MicroKernelParamsTy

================================================================================

[87] 文件: lib/Transform/MatmulOptimizer.cpp : 第 756 行
------------------------------------------------------------
Create an access relation that is specific to
       the matrix multiplication pattern.

Create an access relation of the following form:
[O0, O1, O2, O3, O4, O5, O6, O7, O8] -> [OI, O5, OJ]
where I is @p FirstDim, J is @p SecondDim.

It can be used, for example, to create relations that helps to consequently
access elements of operands of a matrix multiplication after creation of
the BLIS micro and macro kernels.

@see ScheduleTreeOptimizer::createMicroKernel
@see ScheduleTreeOptimizer::createMacroKernel

Subsequently, the described access relation is applied to the range of
@p MapOldIndVar, that is used to map original induction variables to
the ones, which are produced by schedule transformations. It helps to
define relations using a new space and, at the same time, keep them
in the original one.

@param MapOldIndVar The relation, which maps original induction variables
                    to the ones, which are produced by schedule
                    transformations.
@param FirstDim, SecondDim The input dimensions that are used to define
       the specified access relation.
@return The specified access relation.

================================================================================

[88] 文件: lib/Transform/MatmulOptimizer.cpp : 第 896 行
------------------------------------------------------------
Apply the packing transformation.

The packing transformation can be described as a data-layout
transformation that requires to introduce a new array, copy data
to the array, and change memory access locations to reference the array.
It can be used to ensure that elements of the new array are read in-stride
access, aligned to cache lines boundaries, and preloaded into certain cache
levels.

As an example let us consider the packing of the array A that would help
to read its elements with in-stride access. An access to the array A
is represented by an access relation that has the form
S[i, j, k] -> A[i, k]. The scheduling function of the SCoP statement S has
the form S[i,j, k] -> [floor((j mod Nc) / Nr), floor((i mod Mc) / Mr),
k mod Kc, j mod Nr, i mod Mr].

To ensure that elements of the array A are read in-stride access, we add
a new array Packed_A[Mc/Mr][Kc][Mr] to the SCoP, using
Scop::createScopArrayInfo, change the access relation
S[i, j, k] -> A[i, k] to
S[i, j, k] -> Packed_A[floor((i mod Mc) / Mr), k mod Kc, i mod Mr], using
MemoryAccess::setNewAccessRelation, and copy the data to the array, using
the copy statement created by Scop::addScopStmt.

@param Node The schedule node to be optimized.
@param MapOldIndVar The relation, which maps original induction variables
                    to the ones, which are produced by schedule
                    transformations.
@param MicroParams, MacroParams Parameters of the BLIS kernel
                                to be taken into account.
@param MMI Parameters of the matrix multiplication operands.
@return The optimized schedule node.

================================================================================

[89] 文件: lib/Transform/MatmulOptimizer.cpp : 第 950 行
------------------------------------------------------------
Get a relation mapping induction variables produced by schedule
transformations to the original ones.

@param Node The schedule node produced as the result of creation
       of the BLIS kernels.
@param MicroKernelParams, MacroKernelParams Parameters of the BLIS kernel
                                            to be taken into account.
@return  The relation mapping original induction variables to the ones
         produced by schedule transformation.
@see ScheduleTreeOptimizer::createMicroKernel
@see ScheduleTreeOptimizer::createMacroKernel
@see getMacroKernelParams

================================================================================

[90] 文件: lib/Transform/MatmulOptimizer.cpp : 第 975 行
------------------------------------------------------------
Isolate a set of partial tile prefixes and unroll the isolated part.

The set should ensure that it contains only partial tile prefixes that have
exactly Mr x Nr iterations of the two innermost loops produced by
the optimization of the matrix multiplication. Mr and Nr are parameters of
the micro-kernel.

In case of parametric bounds, this helps to auto-vectorize the unrolled
innermost loops, using the SLP vectorizer.

@param Node              The schedule node to be modified.
@param MicroKernelParams Parameters of the micro-kernel
                         to be taken into account.
@return The modified isl_schedule_node.

================================================================================

[91] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1015 行
------------------------------------------------------------
Insert "Loop Vectorizer Disabled" mark node.

@param Node The child of the mark node to be inserted.
@return The modified isl_schedule_node.

================================================================================

[92] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1024 行
------------------------------------------------------------
Restore the initial ordering of dimensions of the band node

In case the band node represents all the dimensions of the iteration
domain, recreate the band node to restore the initial ordering of the
dimensions.

@param Node The band node to be modified.
@return The modified schedule node.

================================================================================

[93] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1084 行
------------------------------------------------------------
Check if this node contains a partial schedule that could
       probably be optimized with analytical modeling.

isMatrMultPattern tries to determine whether the following conditions
are true:
1. the partial schedule contains only one statement.
2. there are exactly three input dimensions.
3. all memory accesses of the statement will have stride 0 or 1, if we
   interchange loops (switch the variable used in the inner loop to
   the outer loop).
4. all memory accesses of the statement except from the last one, are
   read memory access and the last one is write memory access.
5. all subscripts of the last memory access of the statement don't
   contain the variable used in the inner loop.
If this is the case, we could try to use an approach that is similar to
the one used to get close-to-peak performance of matrix multiplications.

@param Node The node to check.
@param D    The SCoP dependencies.
@param MMI  Parameters of the matrix multiplication operands.

================================================================================

[94] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1118 行
------------------------------------------------------------
Get the dimension size.

Return the size of the dimension @p Pos, which is obtained from @p SAI.
Return -1 in the case of the first dimension of a multi-dimensional array,
since the ScopArrayInfo class does not carry size information.

@param SAI The information about the array.
@param Pos The position of the dimension.
@return The size of the dimension.

================================================================================

[95] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1139 行
------------------------------------------------------------
Check whether the access relation has the specified form.

Check that the access relation @p AccMap has the form T[I0, …, In], where
indexes I0, …, In are specified by @p Dimensions.

@param Domain     The domain of the access relation.
@param AccMap     The access relation to be checked.
@param Dimensions The permutation of the subset of the input dimensions.
@return True if @p AccMap has the expected form and false,
        otherwise.

================================================================================

[96] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1177 行
------------------------------------------------------------
Check whether the access represents the tensor contraction operand.

Check that the access relation @p AccMap has the form T[i1, …, in].
Obtained indexes i1, …, in, their sizes and their permutation are stored
into @p IndexSet, @p DimensionSizes, and @p Dimensions, respectively.

@param Domain         The domain of the access relation.
@param AccMap         The access relation to be checked.
@param IndexSet       The subset of the input dimensions.
@param DimensionSizes Sizes of the input dimensions of @p Dimensions.
@param Dimensions     The permutation of the subset of the input dimensions.
@return True if @p AccMap has the expected form and false,
        otherwise.

================================================================================

[97] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1242 行
------------------------------------------------------------
Find the intersection of two sets.

Find the intersection of the set @p A and the set @p B.

@param A, B Sets to intersect.
@return The set intersection.

================================================================================

[98] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1255 行
------------------------------------------------------------
Check whether the set is a superset.

Check that the set @p A is a superset of @p B.

@param A, B Sets to be checked.
@return True if the set A is a superset of B.

================================================================================

[99] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1266 行
------------------------------------------------------------
Find the union of two sets.

Find the union of the set @p A and the set @p B.

@param A, B Sets to unite.
@return The set union.

================================================================================

[100] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1279 行
------------------------------------------------------------
Determine the access that writes to the tensor, which contains
the result of the tensor contraction.

@param Domain        The domain of the statement.
@param Stmt          The statement, which writes to memory.
@param TCI           The information about the tensor contraction.
@param IandJIndexSet The set, which contains free indexes of tensors.
@return The determined MemoryAccess, or nullptr if there is no necessary
        access within the SCoP.

================================================================================

[101] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1311 行
------------------------------------------------------------
Determine an access, which reads elements of an operand of the tensor
contraction

@param MemAccessPtr  The access, which reads elements of the tensor.
@param IndexSet      The set, which contains indexes of the tensors.
@param IandJIndexSet The set, which contains free indexes of tensors.
@param Dimensions    The permutation of the subset of the input dimensions.
@param TCI           The information about the tensor contraction.
@return True if the memory access @p MemAccessPtr corresponds
        to the tensor contraction.

================================================================================

[102] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1360 行
------------------------------------------------------------
Check that all memory accesses of the statement, except from the last
one, are read memory accesses, which read elements of operands of the tensor
contraction and its result.

@param Domain        The domain of the statement.
@param Stmt          The statement, which writes to memory.
@param TCI           The information about the tensor contraction.
@param IandJIndexSet The set, which contains free indexes of tensors.
@return True if all read memory accesses of the statement @p Stmt correspond
        to the tensor contraction.

================================================================================

[103] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1418 行
------------------------------------------------------------
Check accesses to operands of the tensor contraction.

Check that accesses of the SCoP statement, which corresponds to
the partial schedule @p PartialSchedule, represent accesses
to the non-scalar operands of the tensor contraction.

@param  Domain          The domain of the SCoP statement.
@param  PartialSchedule The partial schedule of the SCoP statement.
@param  TCI             Parameters of the tensor contraction operands.
@return                 True if the corresponding SCoP statement
                        represents tensor contraction and false,
                        otherwise.

================================================================================

[104] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1457 行
------------------------------------------------------------
Check that dependency corresponds to the tensor contraction carried over
loop dimension @p Dim.

Check that the dependency has the form
S(..., ki, max(k(i + 1)), ..., max(kn), ...) ->
S(..., ki + 1, min(k(i + 1)), ..., min(kn), ...), where S is the SCoP
statement. For this purpose, we analyze the set @p DepDelta, which
represents the differences between image elements and domain elements of
the corresponding map.

@param  DepDelta    The set contains the differences between image elements
                    and corresponding domain elements of the map, which
                    represents the dependency.
@param  Dim         The position of the index ki.
@param  BoundDeltas In the case of indexes of ki, the difference between
                    image elements and corresponding domain elements
                    corresponds to the difference between lexicographic
                    minimum and lexicographic maximum of the corresponding
                    dimension of the domain of the statement.
@param  IndexSet    Obtained indexes ki, which describe the dependency.
@return True if dependencies correspond to the tensor contraction
        and false, otherwise.

================================================================================

[105] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1522 行
------------------------------------------------------------
Check whether dependencies are over the complete domain.

In the case of the tensor contraction RAW, WAW, WAR dependencies
have the form
S(..., ki, max(k(i + 1)), ..., max(kn), ...) ->
S(..., ki + 1, min(k(i + 1)), ..., min(kn), ...), where S is the SCoP
statement. Consequently, the domain of the dependencies
can be described as
Domain / Domain ∩ S(…, max(kn),…) ∩ S(…, max(k(i + 1)),…),
where Domain is the domain of the statement S.

For example, in the case of the following tensor contraction,
corresponding domains will have the following form.

An example of the tensor contraction:
for (i = 0; i < 1024; i++)
  for (j = 0; j < 1024; j++)
    for (l = 0; l < 64; ++l)
      for (w = 0; w < 64; ++w)
        C[i][j] += A[i][l][w] * B[w][j][l];

The domain of the statement:
{ S[i0, i1, i2, i3] : i0 >= 0 and i0 <= 1023 and
                      i1 >= 0 and i1 <= 1023 and
                      i2 >= 0 and i2 <= 63 and
                      i3 >= 0 and i3 <= 63 }

The domain of the dependencies:
{ S[i0, i1, i2, i3] : (i0 >= 0 and i0 <= 1023 and
                       i1 >= 0 and i1 <= 1023 and
                       i2 >= 0 and i2 <= 63 and
                       i3 >= 0 and i3 <= 62) or
                      (i3 = 63 and i0 >= 0 and i0 <= 1023 and
                       i1 >= 0 and i1 <= 1023 and
                       i2 >= 0 and i2 <= 62) }

@param  Domain       The domain of the statement.
@param  DepsForStmt  RAW and RED dependencies for the statement.
@param  UpperBound   The lexicographic maximum of the elements in
                     the @p Domain.
@param  IndexSet     Obtained indexes ki, which describe the dependencies.
@return True if dependencies are over the complete domain
        and false, otherwise.

================================================================================

[106] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1583 行
------------------------------------------------------------
Check that dependencies correspond to the tensor contraction.

Check that there are only true dependencies of the form
S(..., ki, max(k(i + 1)), ..., max(kn), ...) ->
S(..., ki + 1, min(k(i + 1)), ..., min(kn), ...), where S is the SCoP
statement represented by @p Schedule. Such dependencies are produced by
the tensor contraction. Obtained indexes ki are stored into @p IndexSet.

The form of anti and output dependencies is specified implicitly by
the form the SCoP statement, which is checked by subsequent analysis.

@param  Schedule The schedule of the SCoP statement.
@param  D        The SCoP dependencies.
@param  Domain   The domain of the statement.
@param  IndexSet Obtained indexes ki, which describe the dependencies.
@return True if dependencies correspond to the tensor contraction
        and false, otherwise.

================================================================================

[107] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1639 行
------------------------------------------------------------
Check if the SCoP statement could probably be optimized with analytical
modeling.

containsTCInfoTy tries to determine whether the following conditions
are true:

1. The last memory access modeling an array, MA1, represents writing to
   memory and has the form S(..., I, ..., J, ...) -> M(shuffle(I, J)),
   where S is the SCoP statement under consideration and shuffle(I, J)
   is a permutation of indexes of sets I and J.
2. There are only true dependencies of the form
   S(..., ki, max(k(i + 1)), ..., max(kn), ...) ->
   S(..., ki + 1, min(k(i + 1)), ..., min(kn), ...), where S is the SCoP
   statement represented by @p Schedule and ki are indexes of the set P.
3. SCoP contains an arbitrary number of reads from constants and only three
   access relations, MA2, MA3, and MA4 that represent reading from memory
   and have the form
   S(..., I, ..., P, ...) -> M(shuffle(I, P)),
   S(..., P, ..., J, ...) -> M(shuffle(J, P)),
   S(...) -> M(shuffle(I, J)), respectively.

@param  PartialSchedule The PartialSchedule that contains a SCoP statement
                        to check.
@param  D               The SCoP dependencies.
@param  TCI             Parameters of the tensor contraction operands.
@param  Domain          The domain of the statement.
@return True if dependencies and memory accesses correspond to the tensor
             contraction and false, otherwise.

================================================================================

[108] 文件: lib/Transform/MatmulOptimizer.cpp : 第 1686 行
------------------------------------------------------------
Check if this node contains a partial schedule that could
probably be optimized with analytical modeling.

isTCPattern is used to determine whether the SCoP represents a TC-like
kernel [1], which is a perfectly nested set of loops, with a data usage
pattern that is similar to that produced by the tensor contraction.

A TC-like kernel can be defined as follows:

1. It satisfies the requirements of the polyhedral model.
2. Without loss of generality, it contains three nonempty bundles of
   one-dimensional for-loops with induction variables that are grouped into
   bundles I = i0...i(r-1), J = j0..j(s-1), and P = p0...p(t-1), and they
   are incremented by one.
3. The innermost loop body can be represented as a statement of the form
   C(shuffle(I, J)) = E(A(shuffle(I, P)), B(shuffle(P, J)),
   C(shuffle(I, J))), where A(shuffle(I, P)), B(shuffle(P, J)),
   C(shuffle(I, J)) are accesses to tensors A, B, C, respectively,
   shuffle(I, J), shuffle(I, P), and shuffle(P, J) are permutations of the
   enclosed indices, and E is an expression that contains reads from
   the tensors A, B, C, and an arbitrary number of reads from constants
   with respect to bundles I, J, and P.

TC can be considered as a particular case of a TC-like kernel.

The order of loops with indexes from P should be preserved. Otherwise,
isTCPattern should check if a commutative operation is used.

isTCPattern performs the following steps to check whether the SCoP
corresponds to a definition of a TC-like kernel:

1. Checks that the node is the innermost band node.
2. Checks that the partial schedule contains only one statement.
3. Check that all ancestors of the node contain all band nodes for
   the statement and only mark nodes interleave such band nodes. This
   corresponds to a straightforward implementation of TC.
4. Analyses the dependencies to determine contraction dimensions.
5. Check that the last memory access modeling an array, represents writing
   to the result of the TC-like kernel.
6. Check that SCoP contains only three access relations that represent
   reading of the operands of the TC-like kernel and an arbitrary number of
   reads from constants.

[1] - Gareev R., Grosser T., Kruse M. High-Performance Generalized Tensor
      Operations: A Compiler-Oriented Approach // ACM Transactions
      Architecture and Code Optimization (TACO). 2018.
      Vol. 15, no. 3. P. 34:1–34:27. DOI: 10.1145/3235029.

If this is the case, we could logically represent tensors as matrices and
apply algorithms, which are used to get close-to-peak performance of
matrix multiplications in manually tuned BLAS libraries (e.g., BLIS).

@param Node The node to check.
@param D    The SCoP dependencies.
@param TCI  Parameters of the tensor contraction operands.

================================================================================

[109] 文件: lib/Transform/ZoneAlgo.cpp : 第 177 行
------------------------------------------------------------
Compute the reaching definition of a scalar.

Compared to computeReachingDefinition, there is just one element which is
accessed and therefore only a set if instances that accesses that element is
required.

@param Schedule  { DomainWrite[] -> Scatter[] }
@param Writes    { DomainWrite[] }
@param InclDef   Include the timepoint of the definition to the result.
@param InclRedef Include the timepoint of the overwrite into the result.

@return { Scatter[] -> DomainWrite[] }

================================================================================

[110] 文件: lib/Transform/ZoneAlgo.cpp : 第 204 行
------------------------------------------------------------
Compute the reaching definition of a scalar.

This overload accepts only a single writing statement as an isl_map,
consequently the result also is only a single isl_map.

@param Schedule  { DomainWrite[] -> Scatter[] }
@param Writes    { DomainWrite[] }
@param InclDef   Include the timepoint of the definition to the result.
@param InclRedef Include the timepoint of the overwrite into the result.

@return { Scatter[] -> DomainWrite[] }

================================================================================

[111] 文件: lib/Transform/ZoneAlgo.cpp : 第 233 行
------------------------------------------------------------
Create a domain-to-unknown value mapping.

@see makeUnknownForDomain(isl::union_set)

@param Domain { Domain[] }

@return { Domain[] -> ValInst[] }

================================================================================

[112] 文件: lib/Transform/ZoneAlgo.cpp : 第 273 行
------------------------------------------------------------
Check if all stores in @p Stmt store the very same value.

This covers a special situation occurring in Polybench's
covariance/correlation (which is typical for algorithms that cover symmetric
matrices):

for (int i = 0; i < n; i += 1)
	for (int j = 0; j <= i; j += 1) {
		double x = ...;
		C[i][j] = x;
		C[j][i] = x;
	}

For i == j, the same value is written twice to the same element.Double
writes to the same element are not allowed in DeLICM because its algorithm
does not see which of the writes is effective.But if its the same value
anyway, it doesn't matter.

LLVM passes, however, cannot simplify this because the write is necessary
for i != j (unless it would add a condition for one of the writes to occur
only if i != j).

TODO: In the future we may want to extent this to make the checks
      specific to different memory locations.

================================================================================

[113] 文件: lib/Transform/ZoneAlgo.cpp : 第 477 行
------------------------------------------------------------
For an llvm::Value defined in @p DefStmt, compute the RAW dependency for a
use in every instance of @p UseStmt.

@param UseStmt Statement a scalar is used in.
@param DefStmt Statement a scalar is defined in.

@return { DomainUse[] -> DomainDef[] }

================================================================================

[114] 文件: lib/Transform/ZoneAlgo.cpp : 第 500 行
------------------------------------------------------------
Return whether @p PHI refers (also transitively through other PHIs) to
itself.

loop:
  %phi1 = phi [0, %preheader], [%phi1, %loop]
  br i1 %c, label %loop, label %exit

exit:
  %phi2 = phi [%phi1, %bb]

In this example, %phi1 is recursive, but %phi2 is not.

================================================================================

[115] 文件: lib/Transform/ZoneAlgo.cpp : 第 841 行
------------------------------------------------------------
Remove all computed PHIs out of @p Input and replace by their incoming
value.

@param Input        { [] -> ValInst[] }
@param ComputedPHIs Set of PHIs that are replaced. Its ValInst must appear
                    on the LHS of @p NormalizeMap.
@param NormalizeMap { ValInst[] -> ValInst[] }

================================================================================

[116] 文件: lib/Transform/DeadCodeElimination.cpp : 第 68 行
------------------------------------------------------------
Return the set of live iterations.

The set of live iterations are all iterations that write to memory and for
which we can not prove that there will be a later write that _must_
overwrite the same memory location and is consequently the only one that
is visible after the execution of the SCoP.

To compute the live outs, we compute for the data-locations that are
must-written to the last statement that touches these locations. On top of
this we add all statements that perform may-write accesses.

We could be more precise by removing may-write accesses for which we know
that they are overwritten by a must-write after. However, at the moment the
only may-writes we introduce access the full (unbounded) array, such that
bounded write accesses can not overwrite all of the data-locations. As
this means may-writes are in the current situation always live, there is
no point in trying to remove them from the live-out set.

================================================================================

[117] 文件: lib/Transform/DeadCodeElimination.cpp : 第 101 行
------------------------------------------------------------
Performs polyhedral dead iteration elimination by:
o Assuming that the last write to each location is live.
o Following each RAW dependency from a live iteration backwards and adding
  that iteration to the live set.

To ensure the set of live iterations does not get too complex we always
combine a certain number of precise steps with one approximating step that
simplifies the life set with an affine hull.

================================================================================

[118] 文件: lib/Transform/DeLICM.cpp : 第 86 行
------------------------------------------------------------
Compute the next overwrite for a scalar.

@param Schedule      { DomainWrite[] -> Scatter[] }
                     Schedule of (at least) all writes. Instances not in @p
                     Writes are ignored.
@param Writes        { DomainWrite[] }
                     The element instances that write to the scalar.
@param InclPrevWrite Whether to extend the timepoints to include
                     the timepoint where the previous write happens.
@param InclOverwrite Whether the reaching overwrite includes the timepoint
                     of the overwrite itself.

@return { Scatter[] -> DomainDef[] }

================================================================================

[119] 文件: lib/Transform/DeLICM.cpp : 第 114 行
------------------------------------------------------------
Overload of computeScalarReachingOverwrite, with only one writing statement.
Consequently, the result consists of only one map space.

@param Schedule      { DomainWrite[] -> Scatter[] }
@param Writes        { DomainWrite[] }
@param InclPrevWrite Include the previous write to result.
@param InclOverwrite Include the overwrite to the result.

@return { Scatter[] -> DomainWrite[] }

================================================================================

[120] 文件: lib/Transform/DeLICM.cpp : 第 136 行
------------------------------------------------------------
Try to find a 'natural' extension of a mapped to elements outside its
domain.

@param Relevant The map with mapping that may not be modified.
@param Universe The domain to which @p Relevant needs to be extended.

@return A map with that associates the domain elements of @p Relevant to the
        same elements and in addition the elements of @p Universe to some
        undefined elements. The function prefers to return simple maps.

================================================================================

[121] 文件: lib/Transform/DeLICM.cpp : 第 153 行
------------------------------------------------------------
Represent the knowledge of the contents of any array elements in any zone or
the knowledge we would add when mapping a scalar to an array element.

Every array element at every zone unit has one of two states:

- Unused: Not occupied by any value so a transformation can change it to
  other values.

- Occupied: The element contains a value that is still needed.

The union of Unused and Unknown zones forms the universe, the set of all
elements at every timepoint. The universe can easily be derived from the
array elements that are accessed someway. Arrays that are never accessed
also never play a role in any computation and can hence be ignored. With a
given universe, only one of the sets needs to stored implicitly. Computing
the complement is also an expensive operation, hence this class has been
designed that only one of sets is needed while the other is assumed to be
implicit. It can still be given, but is mostly ignored.

There are two use cases for the Knowledge class:

1) To represent the knowledge of the current state of ScopInfo. The unused
   state means that an element is currently unused: there is no read of it
   before the next overwrite. Also called 'Existing'.

2) To represent the requirements for mapping a scalar to array elements. The
   unused state means that there is no change/requirement. Also called
   'Proposed'.

In addition to these states at unit zones, Knowledge needs to know when
values are written. This is because written values may have no lifetime (one
reason is that the value is never read). Such writes would therefore never
conflict, but overwrite values that might still be required. Another source
of problems are multiple writes to the same element at the same timepoint,
because their order is undefined.

================================================================================

[122] 文件: lib/Transform/DeLICM.cpp : 第 190 行
------------------------------------------------------------
{ [Element[] -> Zone[]] }
Set of array elements and when they are alive.
Can contain a nullptr; in this case the set is implicitly defined as the
complement of #Unused.

The set of alive array elements is represented as zone, as the set of live
values can differ depending on how the elements are interpreted.
Assuming a value X is written at timestep [0] and read at timestep [1]
without being used at any later point, then the value is alive in the
interval ]0,1[. This interval cannot be represented by an integer set, as
it does not contain any integer point. Zones allow us to represent this
interval and can be converted to sets of timepoints when needed (e.g., in
isConflicting when comparing to the write sets).
@see convertZoneToTimepoints and this file's comment for more details.

================================================================================

[123] 文件: lib/Transform/DeLICM.cpp : 第 206 行
------------------------------------------------------------
{ [Element[] -> Zone[]] }
Set of array elements when they are not alive, i.e. their memory can be
used for other purposed. Can contain a nullptr; in this case the set is
implicitly defined as the complement of #Occupied.

================================================================================

[124] 文件: lib/Transform/DeLICM.cpp : 第 212 行
------------------------------------------------------------
{ [Element[] -> Zone[]] -> ValInst[] }
Maps to the known content for each array element at any interval.

Any element/interval can map to multiple known elements. This is due to
multiple llvm::Value referring to the same content. Examples are

- A value stored and loaded again. The LoadInst represents the same value
as the StoreInst's value operand.

- A PHINode is equal to any one of the incoming values. In case of
LCSSA-form, it is always equal to its single incoming value.

Two Knowledges are considered not conflicting if at least one of the known
values match. Not known values are not stored as an unnamed tuple (as
#Written does), but maps to nothing.

 Known values are usually just defined for #Occupied elements. Knowing
 #Unused contents has no advantage as it can be overwritten.

================================================================================

[125] 文件: lib/Transform/DeLICM.cpp : 第 232 行
------------------------------------------------------------
{ [Element[] -> Scatter[]] -> ValInst[] }
The write actions currently in the scop or that would be added when
mapping a scalar. Maps to the value that is written.

Written values that cannot be identified are represented by an unknown
ValInst[] (an unnamed tuple of 0 dimension). It conflicts with itself.

================================================================================

[126] 文件: lib/Transform/DeLICM.cpp : 第 319 行
------------------------------------------------------------
Determine whether two Knowledges conflict with each other.

In theory @p Existing and @p Proposed are symmetric, but the
implementation is constrained by the implicit interpretation. That is, @p
Existing must have #Unused defined (use case 1) and @p Proposed must have
#Occupied defined (use case 1).

A conflict is defined as non-preserved semantics when they are merged. For
instance, when for the same array and zone they assume different
llvm::Values.

@param Existing One of the knowledges with #Unused defined.
@param Proposed One of the knowledges with #Occupied defined.
@param OS       Dump the conflict reason to this output stream; use
                nullptr to not output anything.
@param Indent   Indention for the conflict reason.

@return True, iff the two knowledges are conflicting.

================================================================================

[127] 文件: lib/Transform/DeLICM.cpp : 第 612 行
------------------------------------------------------------
Compute the uses of a MemoryKind::Value and its lifetime (from its
definition to the last use).

@param SAI The ScopArrayInfo representing the value's storage.

@return { DomainDef[] -> DomainUse[] }, { DomainDef[] -> Zone[] }
        First element is the set of uses for each definition.
        The second is the lifetime of each definition.

================================================================================

[128] 文件: lib/Transform/DeLICM.cpp : 第 664 行
------------------------------------------------------------
Try to map a MemoryKind::Value to a given array element.

@param SAI       Representation of the scalar's memory to map.
@param TargetElt { Scatter[] -> Element[] }
                 Suggestion where to map a scalar to when at a timepoint.

@return true if the scalar was successfully mapped.

================================================================================

[129] 文件: lib/Transform/DeLICM.cpp : 第 756 行
------------------------------------------------------------
Map a MemoryKind::Value scalar to an array element.

Callers must have ensured that the mapping is valid and not conflicting.

@param SAI       The ScopArrayInfo representing the scalar's memory to
                 map.
@param DefTarget { DomainDef[] -> Element[] }
                 The array element to map the scalar to.
@param UseTarget { DomainUse[] -> Element[] }
                 The array elements the uses are mapped to.
@param Lifetime  { DomainDef[] -> Zone[] }
                 The lifetime of each llvm::Value definition for
                 reporting.
@param Proposed  Mapping constraints for reporting.

================================================================================

[130] 文件: lib/Transform/DeLICM.cpp : 第 803 行
------------------------------------------------------------
Express the incoming values of a PHI for each incoming statement in an
isl::union_map.

@param SAI The PHI scalar represented by a ScopArrayInfo.

@return { PHIWriteDomain[] -> ValInst[] }

================================================================================

[131] 文件: lib/Transform/DeLICM.cpp : 第 840 行
------------------------------------------------------------
Try to map a MemoryKind::PHI scalar to a given array element.

@param SAI       Representation of the scalar's memory to map.
@param TargetElt { Scatter[] -> Element[] }
                 Suggestion where to map the scalar to when at a
                 timepoint.

@return true if the PHI scalar has been mapped.

================================================================================

[132] 文件: lib/Transform/DeLICM.cpp : 第 959 行
------------------------------------------------------------
Map a MemoryKind::PHI scalar to an array element.

Callers must have ensured that the mapping is valid and not conflicting
with the common knowledge.

@param SAI         The ScopArrayInfo representing the scalar's memory to
                   map.
@param ReadTarget  { DomainRead[] -> Element[] }
                   The array element to map the scalar to.
@param WriteTarget { DomainWrite[] -> Element[] }
                   New access target for each PHI incoming write.
@param Lifetime    { DomainRead[] -> Zone[] }
                   The lifetime of each PHI for reporting.
@param Proposed    Mapping constraints for reporting.

================================================================================

[133] 文件: lib/Transform/DeLICM.cpp : 第 1003 行
------------------------------------------------------------
Search and map scalars to memory overwritten by @p TargetStoreMA.

Start trying to map scalars that are used in the same statement as the
store. For every successful mapping, try to also map scalars of the
statements where those are written. Repeat, until no more mapping
opportunity is found.

There is currently no preference in which order scalars are tried.
Ideally, we would direct it towards a load instruction of the same array
element.

================================================================================

[134] 文件: lib/Transform/DeLICM.cpp : 第 1147 行
------------------------------------------------------------
Determine when an array element is written to, and which value instance is
written.

@return { [Element[] -> Scatter[]] -> ValInst[] }

================================================================================

[135] 文件: lib/Transform/DeLICM.cpp : 第 1159 行
------------------------------------------------------------
Determine whether an access touches at most one element.

The accessed element could be a scalar or accessing an array with constant
subscript, such that all instances access only that element.

@param MA The access to test.

@return True, if zero or one elements are accessed; False if at least two
        different elements are accessed.

================================================================================

[136] 文件: lib/Transform/DeLICM.cpp : 第 1234 行
------------------------------------------------------------
Try to map as many scalars to unused array elements as possible.

Multiple scalars might be mappable to intersecting unused array element
zones, but we can only chose one. This is a greedy algorithm, therefore
the first processed element claims it.

================================================================================

[137] 文件: lib/Transform/ScheduleOptimizer.cpp : 第 229 行
------------------------------------------------------------
Additional parameters of the schedule optimizer.

Target Transform Info and the SCoP dependencies used by the schedule
optimizer.

================================================================================

[138] 文件: lib/Transform/ScheduleOptimizer.cpp : 第 244 行
------------------------------------------------------------
Apply schedule tree transformations.

This function takes an (possibly already optimized) schedule tree and
applies a set of additional optimizations on the schedule tree. The
transformations applied include:

  - Pattern-based optimizations
  - Tiling
  - Prevectorization

@param Schedule The schedule object the transformations will be applied
                to.
@param OAI      Target Transform Info and the SCoP dependencies.
@returns        The transformed schedule.

================================================================================

[139] 文件: lib/Transform/ScheduleOptimizer.cpp : 第 262 行
------------------------------------------------------------
Apply schedule tree transformations.

This function takes a node in an (possibly already optimized) schedule
tree and applies a set of additional optimizations on this schedule tree
node and its descendants. The transformations applied include:

  - Pattern-based optimizations
  - Tiling
  - Prevectorization

@param Node The schedule object post-transformations will be applied to.
@param OAI  Target Transform Info and the SCoP dependencies.
@returns    The transformed schedule.

================================================================================

[140] 文件: lib/Transform/ScheduleOptimizer.cpp : 第 279 行
------------------------------------------------------------
Decide if the @p NewSchedule is profitable for @p S.

@param S           The SCoP we optimize.
@param NewSchedule The new schedule we computed.

@return True, if we believe @p NewSchedule is an improvement for @p S.

================================================================================

[141] 文件: lib/Transform/ScheduleOptimizer.cpp : 第 287 行
------------------------------------------------------------
Isolate a set of partial tile prefixes.

This set should ensure that it contains only partial tile prefixes that
have exactly VectorWidth iterations.

@param Node A schedule node band, which is a parent of a band node,
            that contains a vector loop.
@return Modified isl_schedule_node.

================================================================================

[142] 文件: lib/Transform/ScheduleOptimizer.cpp : 第 299 行
------------------------------------------------------------
Check if this node is a band node we want to tile.

We look for innermost band nodes where individual dimensions are marked as
permutable.

@param Node The node to check.

================================================================================

[143] 文件: lib/Transform/ScheduleOptimizer.cpp : 第 307 行
------------------------------------------------------------
Check if this node is a band node we want to transform using pattern
matching.

We look for innermost band nodes where individual dimensions are marked as
permutable. There is no restriction on the number of individual
dimensions.

@param Node The node to check.

================================================================================

[144] 文件: lib/Transform/ScheduleOptimizer.cpp : 第 317 行
------------------------------------------------------------
Pre-vectorizes one scheduling dimension of a schedule band.

prevectSchedBand splits out the dimension DimToVectorize, tiles it and
sinks the resulting point loop.

Example (DimToVectorize=0, VectorWidth=4):

| Before transformation:
|
| A[i,j] -> [i,j]
|
| for (i = 0; i < 128; i++)
|    for (j = 0; j < 128; j++)
|      A(i,j);

| After transformation:
|
| for (it = 0; it < 32; it+=1)
|    for (j = 0; j < 128; j++)
|      for (ip = 0; ip <= 3; ip++)
|        A(4 * it + ip,j);

The goal of this transformation is to create a trivially vectorizable
loop.  This means a parallel loop at the innermost level that has a
constant number of iterations corresponding to the target vector width.

This transformation creates a loop at the innermost level. The loop has
a constant number of iterations, if the number of loop iterations at
DimToVectorize can be divided by VectorWidth. The default VectorWidth is
currently constant and not yet target specific. This function does not
reason about parallelism.

================================================================================

[145] 文件: lib/Transform/ScheduleOptimizer.cpp : 第 352 行
------------------------------------------------------------
Apply additional optimizations on the bands in the schedule tree.

We are looking for an innermost band node and apply the following
transformations:

 - Tile the band
     - if the band is tileable
     - if the band has more than one loop dimension

 - Prevectorize the schedule of the band (or the point loop in case of
   tiling).
     - if vectorization is enabled

@param Node The schedule node to (possibly) optimize.
@param User A pointer to forward some use information
       (currently unused).

================================================================================

[146] 文件: lib/Transform/ScheduleOptimizer.cpp : 第 664 行
------------------------------------------------------------
Collect statistics for the schedule tree.

@param Schedule The schedule tree to analyze. If not a schedule tree it is
ignored.
@param Version  The version of the schedule tree that is analyzed.
                0 for the original schedule tree before any transformation.
                1 for the schedule tree after isl's rescheduling.
                2 for the schedule tree after optimizations are applied
                (tiling, pattern matching)

================================================================================

[147] 文件: lib/Transform/ForwardOpTree.cpp : 第 92 行
------------------------------------------------------------
The state of whether an operand tree was/can be forwarded.

The items apply to an instructions and its operand tree with the instruction
as the root element. If the value in question is not an instruction in the
SCoP, it can be a leaf of an instruction's operand tree.

================================================================================

[148] 文件: lib/Transform/ForwardOpTree.cpp : 第 104 行
------------------------------------------------------------
The root instruction or value can be forwarded as a leaf of a larger
operand tree.
It does not make sense to move the value itself, it would just replace it
by a use of itself. For instance, a constant "5" used in a statement can
be forwarded, but it would just replace it by the same constant "5".
However, it makes sense to move as an operand of

  %add = add 5, 5

where "5" is moved as part of a larger operand tree. "5" would be placed
(disregarding for a moment that literal constants don't have a location
and can be used anywhere) into the same statement as %add would.

================================================================================

[149] 文件: lib/Transform/ForwardOpTree.cpp : 第 118 行
------------------------------------------------------------
The root instruction can be forwarded and doing so avoids a scalar
dependency.

This can be either because the operand tree can be moved to the target
statement, or a memory access is redirected to read from a different
location.

================================================================================

[150] 文件: lib/Transform/ForwardOpTree.cpp : 第 140 行
------------------------------------------------------------
Callback to execute the forwarding.
Returning true allows deleting the polly::MemoryAccess if the value is the
root of the operand tree (and its elimination the reason why the
forwarding is done). Return false if the MemoryAccess is reused or there
might be other users of the read accesses. In the letter case the
polly::SimplifyPass can remove dead MemoryAccesses.

================================================================================

[151] 文件: lib/Transform/ForwardOpTree.cpp : 第 194 行
------------------------------------------------------------
Implementation of operand tree forwarding for a specific SCoP.

For a statement that requires a scalar value (through a value read
MemoryAccess), see if its operand can be moved into the statement. If so,
the MemoryAccess is removed and the all the operand tree instructions are
moved into the statement. All original instructions are left in the source
statements. The simplification pass can clean these up.

================================================================================

[152] 文件: lib/Transform/ForwardOpTree.cpp : 第 229 行
------------------------------------------------------------
Cache of how to forward values.
The key of this map is the llvm::Value to be forwarded and the
polly::ScopStmt it is forwarded from. This is because the same llvm::Value
can evaluate differently depending on where it is evaluate. For instance,
a synthesizable Scev represents a recurrence with an loop but the loop's
exit value if evaluated after the loop.
The cached results are only valid for the current TargetStmt.
CHECKME: ScalarEvolution::getScevAtScope should take care for getting the
exit value when instantiated outside of the loop. The primary concern is
ambiguity when crossing PHI nodes, which currently is not supported.

================================================================================

[153] 文件: lib/Transform/ForwardOpTree.cpp : 第 241 行
------------------------------------------------------------
Contains the zones where array elements are known to contain a specific
value.
{ [Element[] -> Zone[]] -> ValInst[] }
@see computeKnown()

================================================================================

[154] 文件: lib/Transform/ForwardOpTree.cpp : 第 252 行
------------------------------------------------------------
Get list of array elements that do contain the same ValInst[] at Domain[].

@param ValInst { Domain[] -> ValInst[] }
               The values for which we search for alternative locations,
               per statement instance.

@return { Domain[] -> Element[] }
        For each statement instance, the array elements that contain the
        same ValInst.

================================================================================

[155] 文件: lib/Transform/ForwardOpTree.cpp : 第 292 行
------------------------------------------------------------
Find a single array element for each statement instance, within a single
array.

@param MustKnown { Domain[] -> Element[] }
                 Set of candidate array elements.
@param Domain    { Domain[] }
                 The statement instance for which we need elements for.

@return { Domain[] -> Element[] }
        For each statement instance, an array element out of @p MustKnown.
        All array elements must be in the same array (Polly does not yet
        support reading from different accesses using the same
        MemoryAccess). If no mapping for all of @p Domain exists, returns
        null.

================================================================================

[156] 文件: lib/Transform/ForwardOpTree.cpp : 第 411 行
------------------------------------------------------------
Create a new MemoryAccess of type read and MemoryKind::Array.

@param Stmt           The statement in which the access occurs.
@param LI             The instruction that does the access.
@param AccessRelation The array element that each statement instance
                      accesses.

@param The newly created access.

================================================================================

[157] 文件: lib/Transform/ForwardOpTree.cpp : 第 445 行
------------------------------------------------------------
Forward a load by reading from an array element that contains the same
value. Typically the location it was loaded from.

@param TargetStmt  The statement the operand tree will be copied to.
@param Inst        The (possibly speculatable) instruction to forward.
@param UseStmt     The statement that uses @p Inst.
@param UseLoop     The loop @p Inst is used in.
@param DefStmt     The statement @p Inst is defined in.
@param DefLoop     The loop which contains @p Inst.

@return A ForwardingAction object describing the feasibility and
        profitability evaluation and the callback carrying-out the value
        forwarding.

================================================================================

[158] 文件: lib/Transform/ForwardOpTree.cpp : 第 598 行
------------------------------------------------------------
Forward a scalar by redirecting the access to an array element that stores
the same value.

@param TargetStmt  The statement the operand tree will be copied to.
@param Inst        The scalar to forward.
@param UseStmt     The statement that uses @p Inst.
@param UseLoop     The loop @p Inst is used in.
@param DefStmt     The statement @p Inst is defined in.
@param DefLoop     The loop which contains @p Inst.

@return A ForwardingAction object describing the feasibility and
        profitability evaluation and the callback carrying-out the value
        forwarding.

================================================================================

[159] 文件: lib/Transform/ForwardOpTree.cpp : 第 657 行
------------------------------------------------------------
Forwards a speculatively executable instruction.

@param TargetStmt  The statement the operand tree will be copied to.
@param UseInst     The (possibly speculatable) instruction to forward.
@param DefStmt     The statement @p UseInst is defined in.
@param DefLoop     The loop which contains @p UseInst.

@return A ForwardingAction object describing the feasibility and
        profitability evaluation and the callback carrying-out the value
        forwarding.

================================================================================

[160] 文件: lib/Transform/ForwardOpTree.cpp : 第 725 行
------------------------------------------------------------
Determines whether an operand tree can be forwarded and returns
instructions how to do so in the form of a ForwardingAction object.

@param TargetStmt  The statement the operand tree will be copied to.
@param UseVal      The value (usually an instruction) which is root of an
                   operand tree.
@param UseStmt     The statement that uses @p UseVal.
@param UseLoop     The loop @p UseVal is used in.

@return A ForwardingAction object describing the feasibility and
        profitability evaluation and the callback carrying-out the value
        forwarding.

================================================================================

[161] 文件: lib/Transform/ForwardOpTree.cpp : 第 842 行
------------------------------------------------------------
Determines whether an operand tree can be forwarded. Previous evaluations
are cached.

@param TargetStmt  The statement the operand tree will be copied to.
@param UseVal      The value (usually an instruction) which is root of an
                   operand tree.
@param UseStmt     The statement that uses @p UseVal.
@param UseLoop     The loop @p UseVal is used in.

@return FD_CannotForward        if @p UseVal cannot be forwarded.
        FD_CanForwardLeaf       if @p UseVal is forwardable, but not
                                profitable.
        FD_CanForwardProfitably if @p UseVal is forwardable and useful to
                                do.

================================================================================

[162] 文件: lib/Transform/ForwardOpTree.cpp : 第 876 行
------------------------------------------------------------
Forward an operand tree using cached actions.

@param Stmt   Statement the operand tree is moved into.
@param UseVal Root of the operand tree within @p Stmt.
@param RA     The MemoryAccess for @p UseVal that the forwarding intends
              to remove.

================================================================================

[163] 文件: lib/Transform/ForwardOpTree.cpp : 第 1098 行
------------------------------------------------------------
Pass that redirects scalar reads to array elements that are known to contain
the same value.

This reduces the number of scalar accesses and therefore potentially
increases the freedom of the scheduler. In the ideal case, all reads of a
scalar definition are redirected (We currently do not care about removing
the write in this case).  This is also useful for the main DeLICM pass as
there are less scalars to be mapped.

================================================================================

[164] 文件: lib/Transform/MaximalStaticExpansion.cpp : 第 51 行
------------------------------------------------------------
Print the SCoP.

@param OS The stream where to print.
@param S The SCop that must be printed.

================================================================================

[165] 文件: lib/Transform/MaximalStaticExpansion.cpp : 第 87 行
------------------------------------------------------------
Filter the dependences to have only one related to current memory access.

@param S The SCop in which the memory access appears in.
@param MapDependences The dependences to filter.
@param MA The memory access that need to be expanded.

================================================================================

[166] 文件: lib/Transform/MaximalStaticExpansion.cpp : 第 130 行
------------------------------------------------------------
Return true if the SAI in parameter is expandable.

@param SAI the SAI that need to be checked.
@param Writes A set that will contains all the write accesses.
@param Reads A set that will contains all the read accesses.
@param S The SCop in which the SAI is in.
@param Dependences The RAW dependences of the SCop.

================================================================================

[167] 文件: lib/Transform/MaximalStaticExpansion.cpp : 第 279 行
------------------------------------------------------------
Expand the MemoryAccess according to Dependences and already expanded
MemoryAccesses.

@param The SCop in which the memory access appears in.
@param The memory access that need to be expanded.
@param Dependences The RAW dependences of the SCop.
@param ExpandedSAI The expanded SAI created during write expansion.
@param Reverse if true, the Dependences union_map is reversed before
intersection.

================================================================================

[168] 文件: lib/Transform/MaximalStaticExpansion.cpp : 第 321 行
------------------------------------------------------------
Expand the MemoryAccess according to its domain.

@param S The SCop in which the memory access appears in.
@param MA The memory access that need to be expanded.

================================================================================

[169] 文件: lib/Transform/MaximalStaticExpansion.cpp : 第 394 行
------------------------------------------------------------
Expand PHI memory accesses.

@param The SCop in which the memory access appears in.
@param The ScopArrayInfo representing the PHI accesses to expand.
@param Dependences The RAW dependences of the SCop.

================================================================================

[170] 文件: lib/Transform/MaximalStaticExpansion.cpp : 第 414 行
------------------------------------------------------------
Expand the accesses of the SCoP

@param S The SCoP that must be expanded
@param D The dependencies information of SCoP

================================================================================

[171] 文件: lib/Transform/ScheduleTreeTransform.cpp : 第 122 行
------------------------------------------------------------
Rewrite a schedule tree by reconstructing it bottom-up.

By default, the original schedule tree is reconstructed. To build a
different tree, redefine visitor methods in a derived class (CRTP).

Note that AST build options are not applied; Setting the isolate[] option
makes the schedule tree 'anchored' and cannot be modified afterwards. Hence,
AST build options must be set after the tree has been constructed.

================================================================================

[172] 文件: lib/Transform/ScheduleTreeTransform.cpp : 第 218 行
------------------------------------------------------------
Rewrite a schedule tree to an equivalent one without extension nodes.

Each visit method takes two additional arguments:

 * The new domain the node, which is the inherited domain plus any domains
   added by extension nodes.

 * A map of extension domains of all children is returned; it is required by
   band nodes to schedule the additional domains at the same position as the
   extension node would.


================================================================================

[173] 文件: lib/Transform/ScheduleTreeTransform.cpp : 第 356 行
------------------------------------------------------------
Collect all AST build options in any schedule tree band.

ScheduleTreeRewriter cannot apply the schedule tree options. This class
collects these options to apply them later.

================================================================================

[174] 文件: lib/Transform/ScheduleTreeTransform.cpp : 第 375 行
------------------------------------------------------------
Apply AST build options to the bands in a schedule tree.

This rewrites a schedule tree with the AST build options applied. We assume
that the band nodes are visited in the same order as they were when the
build options were collected, typically by CollectASTBuildOptions.

================================================================================

[175] 文件: lib/Transform/ScheduleTreeTransform.cpp : 第 520 行
------------------------------------------------------------
Return the (one-dimensional) set of numbers that are divisible by @p Factor
with remainder @p Offset.

 isDivisibleBySet(Ctx, 4, 0) = { [i] : floord(i,4) = 0 }
 isDivisibleBySet(Ctx, 4, 1) = { [i] : floord(i,4) = 1 }


================================================================================

[176] 文件: lib/Transform/ScheduleTreeTransform.cpp : 第 543 行
------------------------------------------------------------
Make the last dimension of Set to take values from 0 to VectorWidth - 1.

@param Set         A set, which should be modified.
@param VectorWidth A parameter, which determines the constraint.

================================================================================

[177] 文件: lib/Transform/ScheduleTreeTransform.cpp : 第 833 行
------------------------------------------------------------
Fuse all fusable loop top-down in a schedule tree.

The isl::union_map parameters is the set of validity dependencies that have
not been resolved/carried by a parent schedule node.

================================================================================

[178] 文件: include/ScopInfo.h : 第 81 行
------------------------------------------------------------
The different memory kinds used in Polly.

We distinguish between arrays and various scalar memory objects. We use
the term ``array'' to describe memory objects that consist of a set of
individual data elements arranged in a multi-dimensional grid. A scalar
memory object describes an individual data element and is used to model
the definition and uses of llvm::Values.

The polyhedral model does traditionally not reason about SSA values. To
reason about llvm::Values we model them "as if" they were zero-dimensional
memory objects, even though they were not actually allocated in (main)
memory.  Memory for such objects is only alloca[ed] at CodeGeneration
time. To relate the memory slots used during code generation with the
llvm::Values they belong to the new names for these corresponding stack
slots are derived by appending suffixes (currently ".s2a" and ".phiops")
to the name of the original llvm::Value. To describe how def/uses are
modeled exactly we use these suffixes here as well.

There are currently four different kinds of memory objects:

================================================================================

[179] 文件: include/ScopInfo.h : 第 101 行
------------------------------------------------------------
MemoryKind::Array: Models a one or multi-dimensional array

A memory object that can be described by a multi-dimensional array.
Memory objects of this type are used to model actual multi-dimensional
arrays as they exist in LLVM-IR, but they are also used to describe
other objects:
  - A single data element allocated on the stack using 'alloca' is
    modeled as a one-dimensional, single-element array.
  - A single data element allocated as a global variable is modeled as
    one-dimensional, single-element array.
  - Certain multi-dimensional arrays with variable size, which in
    LLVM-IR are commonly expressed as a single-dimensional access with a
    complicated access function, are modeled as multi-dimensional
    memory objects (grep for "delinearization").

================================================================================

[180] 文件: include/ScopInfo.h : 第 117 行
------------------------------------------------------------
MemoryKind::Value: Models an llvm::Value

Memory objects of type MemoryKind::Value are used to model the data flow
induced by llvm::Values. For each llvm::Value that is used across
BasicBlocks, one ScopArrayInfo object is created. A single memory WRITE
stores the llvm::Value at its definition into the memory object and at
each use of the llvm::Value (ignoring trivial intra-block uses) a
corresponding READ is added. For instance, the use/def chain of a
llvm::Value %V depicted below
             ______________________
             |DefBB:              |
             |  %V = float op ... |
             ----------------------
              |                  |
_________________               _________________
|UseBB1:        |               |UseBB2:        |
|  use float %V |               |  use float %V |
-----------------               -----------------

is modeled as if the following memory accesses occurred:

                       __________________________
                       |entry:                  |
                       |  %V.s2a = alloca float |
                       --------------------------
                                    |
                   ___________________________________
                   |DefBB:                           |
                   |  store %float %V, float* %V.s2a |
                   -----------------------------------
                          |                   |
____________________________________ ___________________________________
|UseBB1:                           | |UseBB2:                          |
|  %V.reload1 = load float* %V.s2a | |  %V.reload2 = load float* %V.s2a|
|  use float %V.reload1            | |  use float %V.reload2           |
------------------------------------ -----------------------------------


================================================================================

[181] 文件: include/ScopInfo.h : 第 156 行
------------------------------------------------------------
MemoryKind::PHI: Models PHI nodes within the SCoP

Besides the MemoryKind::Value memory object used to model the normal
llvm::Value dependences described above, PHI nodes require an additional
memory object of type MemoryKind::PHI to describe the forwarding of values
to
the PHI node.

As an example, a PHIInst instructions

%PHI = phi float [ %Val1, %IncomingBlock1 ], [ %Val2, %IncomingBlock2 ]

is modeled as if the accesses occurred this way:

                   _______________________________
                   |entry:                       |
                   |  %PHI.phiops = alloca float |
                   -------------------------------
                          |              |
__________________________________  __________________________________
|IncomingBlock1:                 |  |IncomingBlock2:                 |
|  ...                           |  |  ...                           |
|  store float %Val1 %PHI.phiops |  |  store float %Val2 %PHI.phiops |
|  br label % JoinBlock          |  |  br label %JoinBlock           |
----------------------------------  ----------------------------------
                            \            /
                             \          /
              _________________________________________
              |JoinBlock:                             |
              |  %PHI = load float, float* PHI.phiops |
              -----------------------------------------

Note that there can also be a scalar write access for %PHI if used in a
different BasicBlock, i.e. there can be a memory object %PHI.phiops as
well as a memory object %PHI.s2a.

================================================================================

[182] 文件: include/ScopInfo.h : 第 193 行
------------------------------------------------------------
MemoryKind::ExitPHI: Models PHI nodes in the SCoP's exit block

For PHI nodes in the Scop's exit block a special memory object kind is
used. The modeling used is identical to MemoryKind::PHI, with the
exception
that there are no READs from these memory objects. The PHINode's
llvm::Value is treated as a value escaping the SCoP. WRITE accesses
write directly to the escaping value's ".s2a" alloca.

================================================================================

[183] 文件: include/ScopInfo.h : 第 204 行
------------------------------------------------------------
Maps from a loop to the affine function expressing its backedge taken count.
The backedge taken count already enough to express iteration domain as we
only allow loops with canonical induction variable.
A canonical induction variable is:
an integer recurrence that starts at 0 and increments by one each time
through the loop.

================================================================================

[184] 文件: include/ScopInfo.h : 第 214 行
------------------------------------------------------------
A class to store information about arrays in the SCoP.

Objects are accessible via the ScoP, MemoryAccess or the id associated with
the MemoryAccess access function.


================================================================================

[185] 文件: include/ScopInfo.h : 第 221 行
------------------------------------------------------------
Construct a ScopArrayInfo object.

@param BasePtr        The array base pointer.
@param ElementType    The type of the elements stored in the array.
@param IslCtx         The isl context used to create the base pointer id.
@param DimensionSizes A vector containing the size of each dimension.
@param Kind           The kind of the array object.
@param DL             The data layout of the module.
@param S              The scop this array object belongs to.
@param BaseName       The optional name of this memory reference.

================================================================================

[186] 文件: include/ScopInfo.h : 第 238 行
------------------------------------------------------------
 Update the element type of the ScopArrayInfo object.

 Memory accesses referencing this ScopArrayInfo object may use
 different element sizes. This function ensures the canonical element type
 stored is small enough to model accesses to the current element type as
 well as to @p NewElementType.

 @param NewElementType An element type that is used to access this array.

================================================================================

[187] 文件: include/ScopInfo.h : 第 248 行
------------------------------------------------------------
 Update the sizes of the ScopArrayInfo object.

 A ScopArrayInfo object may be created without all outer dimensions being
 available. This function is called when new memory accesses are added for
 this ScopArrayInfo object. It verifies that sizes are compatible and adds
 additional outer array dimensions, if needed.

 @param Sizes       A vector of array sizes where the rightmost array
                    sizes need to match the innermost array sizes already
                    defined in SAI.
 @param CheckConsistency Update sizes, even if new sizes are inconsistent
                         with old sizes

================================================================================

[188] 文件: include/ScopInfo.h : 第 327 行
------------------------------------------------------------
Is this array info modeling special PHI node memory?

During code generation of PHI nodes, there is a need for two kinds of
virtual storage. The normal one as it is used for all scalar dependences,
where the result of the PHI node is stored and later loaded from as well
as a second one where the incoming values of the PHI nodes are stored
into and reloaded when the PHI is executed. As both memories use the
original PHI node as virtual base pointer, we have this additional
attribute to distinguish the PHI node specific array modeling from the
normal scalar array modeling.

================================================================================

[189] 文件: include/ScopInfo.h : 第 345 行
------------------------------------------------------------
Is this array allocated on heap

This property is only relevant if the array is allocated by Polly instead
of pre-existing. If false, it is allocated using alloca instead malloca.

================================================================================

[190] 文件: include/ScopInfo.h : 第 373 行
------------------------------------------------------------
Verify that @p Array is compatible to this ScopArrayInfo.

Two arrays are compatible if their dimensionality, the sizes of their
dimensions, and their element sizes match.

@param Array The array to compare against.

@returns True, if the arrays are compatible, False otherwise.

================================================================================

[191] 文件: include/ScopInfo.h : 第 397 行
------------------------------------------------------------
The canonical element type of this array.

The canonical element type describes the minimal accessible element in
this array. Not all elements accessed, need to be of the very same type,
but the allocation size of the type of the elements loaded/stored from/to
this array needs to be a multiple of the allocation size of the canonical
type.

================================================================================

[192] 文件: include/ScopInfo.h : 第 437 行
------------------------------------------------------------
The access type of a memory access

There are three kind of access types:

* A read access

A certain set of memory locations are read and may be used for internal
calculations.

* A must-write access

A certain set of memory locations is definitely written. The old value is
replaced by a newly calculated value. The old value is not read or used at
all.

* A may-write access

A certain set of memory locations may be written. The memory location may
contain a new value if there is actually a write or the old value may
remain, if no write happens.

================================================================================

[193] 文件: include/ScopInfo.h : 第 480 行
------------------------------------------------------------
A unique identifier for this memory access.

The identifier is unique between all memory accesses belonging to the same
scop statement.

================================================================================

[194] 文件: include/ScopInfo.h : 第 494 行
------------------------------------------------------------
Reduction type for reduction like accesses, RT_NONE otherwise

An access is reduction like if it is part of a load-store chain in which
both access the same memory location (use the same LLVM-IR value
as pointer reference). Furthermore, between the load and the store there
is exactly one binary operator which is known to be associative and
commutative.

TODO:

We can later lift the constraint that the same LLVM-IR value defines the
memory location to handle scops such as the following:

   for i
     for j
       sum[i+j] = sum[i] + 3;

Here not all iterations access the same memory location, but iterations
for which j = 0 holds do. After lifting the equality check in ScopBuilder,
subsequent transformations do not only need check if a statement is
reduction like, but they also need to verify that the reduction
property is only exploited for statement instances that load from and
store to the same data location. Doing so at dependence analysis time
could allow us to handle the above example.

================================================================================

[195] 文件: include/ScopInfo.h : 第 523 行
------------------------------------------------------------
The domain under which this access is not modeled precisely.

The invalid domain for an access describes all parameter combinations
under which the statement looks to be executed but is in fact not because
some assumption/restriction makes the access invalid.

================================================================================

[196] 文件: include/ScopInfo.h : 第 534 行
------------------------------------------------------------
The base address (e.g., A for A[i+j]).

The #BaseAddr of a memory access of kind MemoryKind::Array is the base
pointer of the memory access.
The #BaseAddr of a memory access of kind MemoryKind::PHI or
MemoryKind::ExitPHI is the PHI node itself.
The #BaseAddr of a memory access of kind MemoryKind::Value is the
instruction defining the value.

================================================================================

[197] 文件: include/ScopInfo.h : 第 554 行
------------------------------------------------------------
The access instruction of this memory access.

For memory accesses of kind MemoryKind::Array the access instruction is
the Load or Store instruction performing the access.

For memory accesses of kind MemoryKind::PHI or MemoryKind::ExitPHI the
access instruction of a load access is the PHI instruction. The access
instruction of a PHI-store is the incoming's block's terminator
instruction.

For memory accesses of kind MemoryKind::Value the access instruction of a
load access is nullptr because generally there can be multiple
instructions in the statement using the same llvm::Value. The access
instruction of a write access is the instruction that defines the
llvm::Value.

================================================================================

[198] 文件: include/ScopInfo.h : 第 574 行
------------------------------------------------------------
The value associated with this memory access.

 - For array memory accesses (MemoryKind::Array) it is the loaded result
   or the stored value. If the access instruction is a memory intrinsic it
   the access value is also the memory intrinsic.
 - For accesses of kind MemoryKind::Value it is the access instruction
   itself.
 - For accesses of kind MemoryKind::PHI or MemoryKind::ExitPHI it is the
   PHI node itself (for both, READ and WRITE accesses).


================================================================================

[199] 文件: include/ScopInfo.h : 第 592 行
------------------------------------------------------------
Relation from statement instances to the accessed array elements.

In the common case this relation is a function that maps a set of loop
indices to the memory address from which a value is loaded/stored:

     for i
       for j
   S:     A[i + 3 j] = ...

   => { S[i,j] -> A[i + 3j] }

In case the exact access function is not known, the access relation may
also be a one to all mapping { S[i,j] -> A[o] } describing that any
element accessible through A might be accessed.

In case of an access to a larger element belonging to an array that also
contains smaller elements, the access relation models the larger access
with multiple smaller accesses of the size of the minimal array element
type:

     short *A;

     for i
   S:     A[i] = *((double*)&A[4 * i]);

   => { S[i] -> A[i]; S[i] -> A[o] : 4i <= o <= 4i + 3 }

================================================================================

[200] 文件: include/ScopInfo.h : 第 642 行
------------------------------------------------------------
Fold the memory access to consider parametric offsets

To recover memory accesses with array size parameters in the subscript
expression we post-process the delinearization results.

We would normally recover from an access A[exp0(i) * N + exp1(i)] into an
array A[][N] the 2D access A[exp0(i)][exp1(i)]. However, another valid
delinearization is A[exp0(i) - 1][exp1(i) + N] which - depending on the
range of exp1(i) - may be preferable. Specifically, for cases where we
know exp1(i) is negative, we want to choose the latter expression.

As we commonly do not have any information about the range of exp1(i),
we do not choose one of the two options, but instead create a piecewise
access function that adds the (-1, N) offsets as soon as exp1(i) becomes
negative. For a 2D array such an access function is created by applying
the piecewise map:

[i,j] -> [i, j] :      j >= 0
[i,j] -> [i-1, j+N] :  j <  0

We can generalize this mapping to arbitrary dimensions by applying this
piecewise mapping pairwise from the rightmost to the leftmost access
dimension. It would also be possible to cover a wider range by introducing
more cases and adding multiple of Ns to these cases. However, this has
not yet been necessary.
The introduction of different cases necessarily complicates the memory
access function, but cases that can be statically proven to not happen
will be eliminated later on.

================================================================================

[201] 文件: include/ScopInfo.h : 第 675 行
------------------------------------------------------------
Assemble the access relation from all available information.

In particular, used the information passes in the constructor and the
parent ScopStmt set by setStatment().

@param SAI Info object for the accessed array.

================================================================================

[202] 文件: include/ScopInfo.h : 第 683 行
------------------------------------------------------------
Carry index overflows of dimensions with constant size to the next higher
dimension.

For dimensions that have constant size, modulo the index by the size and
add up the carry (floored division) to the next higher dimension. This is
how overflow is defined in row-major order.
It happens e.g. when ScalarEvolution computes the offset to the base
pointer and would algebraically sum up all lower dimensions' indices of
constant size.

Example:
  float (*A)[4];
  A[1][6] -> A[2][2]

================================================================================

[203] 文件: include/ScopInfo.h : 第 699 行
------------------------------------------------------------
Create a new MemoryAccess.

@param Stmt       The parent statement.
@param AccessInst The instruction doing the access.
@param BaseAddr   The accessed array's address.
@param ElemType   The type of the accessed array elements.
@param AccType    Whether read or write access.
@param IsAffine   Whether the subscripts are affine expressions.
@param Kind       The kind of memory accessed.
@param Subscripts Subscript expressions
@param Sizes      Dimension lengths of the accessed array.

================================================================================

[204] 文件: include/ScopInfo.h : 第 715 行
------------------------------------------------------------
Create a new MemoryAccess that corresponds to @p AccRel.

Along with @p Stmt and @p AccType it uses information about dimension
lengths of the accessed array, the type of the accessed array elements,
the name of the accessed array that is derived from the object accessible
via @p AccRel.

@param Stmt       The parent statement.
@param AccType    Whether read or write access.
@param AccRel     The access relation that describes the memory access.

================================================================================

[205] 文件: include/ScopInfo.h : 第 731 行
------------------------------------------------------------
Add a new incoming block/value pairs for this PHI/ExitPHI access.

@param IncomingBlock The PHI's incoming block.
@param IncomingValue The value when reaching the PHI from the @p
                     IncomingBlock.

================================================================================

[206] 文件: include/ScopInfo.h : 第 742 行
------------------------------------------------------------
Return the list of possible PHI/ExitPHI values.

After code generation moves some PHIs around during region simplification,
we cannot reliably locate the original PHI node and its incoming values
anymore. For this reason we remember these explicitly for all PHI-kind
accesses.

================================================================================

[207] 文件: include/ScopInfo.h : 第 779 行
------------------------------------------------------------
Return the newest access relation of this access.

There are two possibilities:
  1) The original access relation read from the LLVM-IR.
  2) A new access relation imported from a json file or set by another
     pass (e.g., for privatization).

As 2) is by construction "newer" than 1) we return the new access
relation if present.


================================================================================

[208] 文件: include/ScopInfo.h : 第 797 行
------------------------------------------------------------
Get an isl map describing the memory address accessed.

In most cases the memory address accessed is well described by the access
relation obtained with getAccessRelation. However, in case of arrays
accessed with types of different size the access relation maps one access
to multiple smaller address locations. This method returns an isl map that
relates each dynamic statement instance to the unique memory location
that is loaded from / stored to.

For an access relation { S[i] -> A[o] : 4i <= o <= 4i + 3 } this method
will return the address function { S[i] -> A[4i] }.

@returns The address function for this memory access.

================================================================================

[209] 文件: include/ScopInfo.h : 第 825 行
------------------------------------------------------------
Get the original base address of this access (e.g. A for A[i+j]) when
detected.

This address may differ from the base address referenced by the original
ScopArrayInfo to which this array belongs, as this memory access may
have been canonicalized to a ScopArrayInfo which has a different but
identically-valued base pointer in case invariant load hoisting is
enabled.

================================================================================

[210] 文件: include/ScopInfo.h : 第 869 行
------------------------------------------------------------
Return llvm::Value that is stored by this access, if available.

PHI nodes may not have a unique value available that is stored, as in
case of region statements one out of possibly several llvm::Values
might be stored. In this case nullptr is returned.

================================================================================

[211] 文件: include/ScopInfo.h : 第 919 行
------------------------------------------------------------
Is consecutive memory accessed for a given statement instance set?
Schedule is a map from the statement to a schedule where the innermost
dimension is the dimension of the innermost loop containing the
statement.

================================================================================

[212] 文件: include/ScopInfo.h : 第 925 行
------------------------------------------------------------
Is always the same memory accessed for a given statement instance set?
Schedule is a map from the statement to a schedule where the innermost
dimension is the dimension of the innermost loop containing the
statement.

================================================================================

[213] 文件: include/ScopInfo.h : 第 957 行
------------------------------------------------------------
Whether this access is an array to a scalar memory object, without
considering changes by setNewAccessRelation.

Scalar accesses are accesses to MemoryKind::Value, MemoryKind::PHI or
MemoryKind::ExitPHI.

================================================================================

[214] 文件: include/ScopInfo.h : 第 1036 行
------------------------------------------------------------
Update the original access relation.

We need to update the original access relation during scop construction,
when unifying the memory accesses that access the same scop array info
object. After the scop has been constructed, the original access relation
should not be changed any more. Instead setNewAccessRelation should
be called.

================================================================================

[215] 文件: include/ScopInfo.h : 第 1058 行
------------------------------------------------------------
Update the dimensionality of the memory access.

During scop construction some memory accesses may not be constructed with
their full dimensionality, but outer dimensions may have been omitted if
they took the value 'zero'. By updating the dimensionality of the
statement we add additional zero-valued dimensions to match the
dimensionality of the ScopArrayInfo object that belongs to this memory
access.

================================================================================

[216] 文件: include/ScopInfo.h : 第 1068 行
------------------------------------------------------------
Get identifier for the memory access.

This identifier is unique for all accesses that belong to the same scop
statement.

================================================================================

[217] 文件: include/ScopInfo.h : 第 1110 行
------------------------------------------------------------
Memory accesses now treated invariant

These memory accesses access the pointer location that identifies
this equivalence class. They are treated as invariant and hoisted during
code generation.

================================================================================

[218] 文件: include/ScopInfo.h : 第 1117 行
------------------------------------------------------------
The execution context under which the memory location is accessed

It is the union of the execution domains of the memory accesses in the
InvariantAccesses list.

================================================================================

[219] 文件: include/ScopInfo.h : 第 1123 行
------------------------------------------------------------
The type of the invariant access

It is used to differentiate between differently typed invariant loads from
the same location.

================================================================================

[220] 文件: include/ScopInfo.h : 第 1133 行
------------------------------------------------------------
Statement of the Scop

A Scop statement represents an instruction in the Scop.

It is further described by its iteration domain, its schedule and its data
accesses.
At the moment every statement represents a single basic block of LLVM-IR.

================================================================================

[221] 文件: include/ScopInfo.h : 第 1149 行
------------------------------------------------------------
Create an overapproximating ScopStmt for the region @p R.

@param EntryBlockInstructions The list of instructions that belong to the
                              entry block of the region statement.
                              Instructions are only tracked for entry
                              blocks for now. We currently do not allow
                              to modify the instructions of blocks later
                              in the region statement.

================================================================================

[222] 文件: include/ScopInfo.h : 第 1160 行
------------------------------------------------------------
Create a copy statement.

@param Stmt       The parent statement.
@param SourceRel  The source location.
@param TargetRel  The target location.
@param Domain     The original domain under which the copy statement would
                  be executed.

================================================================================

[223] 文件: include/ScopInfo.h : 第 1181 行
------------------------------------------------------------
The domain under which this statement is not modeled precisely.

The invalid domain for a statement describes all parameter combinations
under which the statement looks to be executed but is in fact not because
some assumption/restriction makes the statement/scop invalid.

================================================================================

[224] 文件: include/ScopInfo.h : 第 1188 行
------------------------------------------------------------
The iteration domain describes the set of iterations for which this
statement is executed.

Example:
    for (i = 0; i < 100 + b; ++i)
      for (j = 0; j < i; ++j)
        S(i,j);

'S' is executed for different values of i and j. A vector of all
induction variables around S (i, j) is called iteration vector.
The domain describes the set of possible iteration vectors.

In this case it is:

    Domain: 0 <= i <= 100 + b
            0 <= j <= i

A pair of statement and iteration vector (S, (5,3)) is called statement
instance.

================================================================================

[225] 文件: include/ScopInfo.h : 第 1225 行
------------------------------------------------------------
Map from PHI nodes to its incoming value when coming from this
       statement.

Non-affine subregions can have multiple exiting blocks that are incoming
blocks of the PHI nodes. This map ensures that there is only one write
operation for the complete subregion. A PHI selecting the relevant value
will be inserted.

================================================================================

[226] 文件: include/ScopInfo.h : 第 1239 行
------------------------------------------------------------
A SCoP statement represents either a basic block (affine/precise case) or
a whole region (non-affine case).

Only one of the following two members will therefore be set and indicate
which kind of statement this is.

{

================================================================================

[227] 文件: include/ScopInfo.h : 第 1293 行
------------------------------------------------------------
Get the schedule function of this ScopStmt.

@return The schedule function of this ScopStmt, if it does not contain
extension nodes, and nullptr, otherwise.

================================================================================

[228] 文件: include/ScopInfo.h : 第 1299 行
------------------------------------------------------------
Get an isl string representing this schedule.

@return An isl string representing this schedule, if it does not contain
extension nodes, and an empty string, otherwise.

================================================================================

[229] 文件: include/ScopInfo.h : 第 1314 行
------------------------------------------------------------
Get the BasicBlock represented by this ScopStmt (if any).

@return The BasicBlock represented by this ScopStmt, or null if the
        statement represents a region.

================================================================================

[230] 文件: include/ScopInfo.h : 第 1326 行
------------------------------------------------------------
Get the region represented by this ScopStmt (if any).

@return The region represented by this ScopStmt, or null if the statement
        represents a basic block.

================================================================================

[231] 文件: include/ScopInfo.h : 第 1335 行
------------------------------------------------------------
Return a BasicBlock from this statement.

For block statements, it returns the BasicBlock itself. For subregion
statements, return its entry block.

================================================================================

[232] 文件: include/ScopInfo.h : 第 1368 行
------------------------------------------------------------
Return the closest innermost loop that contains this statement, but is not
contained in it.

For block statement, this is just the loop that contains the block. Region
statements can contain boxed loops, so getting the loop of one of the
region's BBs might return such an inner loop. For instance, the region's
entry could be a header of a loop, but the region might extend to BBs
after the loop exit. Similarly, the region might only contain parts of the
loop body and still include the loop header.

Most of the time the surrounding loop is the top element of #NestLoops,
except when it is empty. In that case it return the loop that the whole
SCoP is contained in. That can be nullptr if there is no such loop.

================================================================================

[233] 文件: include/ScopInfo.h : 第 1390 行
------------------------------------------------------------
Find all array accesses for @p Inst.

@param Inst The instruction accessing an array.

@return A list of array accesses (MemoryKind::Array) accessed by @p Inst.
        If there is no such access, it returns nullptr.

================================================================================

[234] 文件: include/ScopInfo.h : 第 1406 行
------------------------------------------------------------
Return the only array access for @p Inst, if existing.

@param Inst The instruction for which to look up the access.
@returns The unique array memory access related to Inst or nullptr if
         no array access exists

================================================================================

[235] 文件: include/ScopInfo.h : 第 1430 行
------------------------------------------------------------
Return the only array access for @p Inst.

@param Inst The instruction for which to look up the access.
@returns The unique array memory access related to Inst.

================================================================================

[236] 文件: include/ScopInfo.h : 第 1470 行
------------------------------------------------------------
Return the input access of the value, or null if no such MemoryAccess
exists.

The input access is the MemoryAccess that makes an inter-statement value
available in this statement by reading it at the start of this statement.
This can be a MemoryKind::Value if defined in another statement or a
MemoryKind::PHI if the value is a PHINode in this statement.

================================================================================

[237] 文件: include/ScopInfo.h : 第 1492 行
------------------------------------------------------------
Add @p Access to this statement's list of accesses.

@param Access  The access to add.
@param Prepend If true, will add @p Access before all other instructions
               (instead of appending it).

================================================================================

[238] 文件: include/ScopInfo.h : 第 1499 行
------------------------------------------------------------
Remove a MemoryAccess from this statement.

Note that scalar accesses that are caused by MA will
be eliminated too.

================================================================================

[239] 文件: include/ScopInfo.h : 第 1505 行
------------------------------------------------------------
Remove @p MA from this statement.

In contrast to removeMemoryAccess(), no other access will be eliminated.

@param MA            The MemoryAccess to be removed.
@param AfterHoisting If true, also remove from data access lists.
                     These lists are filled during
                     ScopBuilder::buildAccessRelations. Therefore, if this
                     method is called before buildAccessRelations, false
                     must be passed.

================================================================================

[240] 文件: include/ScopInfo.h : 第 1572 行
------------------------------------------------------------
Get the loop for a dimension.

@param Dimension The dimension of the induction variable
@return The loop at a certain dimension.

================================================================================

[241] 文件: include/ScopInfo.h : 第 1581 行
------------------------------------------------------------
Print the ScopStmt.

@param OS                The output stream the ScopStmt is printed to.
@param PrintInstructions Whether to print the statement's instructions as
                         well.

================================================================================

[242] 文件: include/ScopInfo.h : 第 1592 行
------------------------------------------------------------
Check whether there is a value read access for @p V in this statement, and
if not, create one.

This allows to add MemoryAccesses after the initial creation of the Scop
by ScopBuilder.

@return The already existing or newly created MemoryKind::Value READ
MemoryAccess.

@see ScopBuilder::ensureValueRead(Value*,ScopStmt*)

================================================================================

[243] 文件: include/ScopInfo.h : 第 1613 行
------------------------------------------------------------
Static Control Part

A Scop is the polyhedral representation of a control flow region detected
by the Scop detection. It is generated by translating the LLVM-IR and
abstracting its effects.

A Scop consists of a set of:

  * A set of statements executed in the Scop.

  * A set of global parameters
  Those parameters are scalar integer values, which are constant during
  execution.

  * A context
  This context contains information about the values the parameters
  can take and relations between different parameters.

================================================================================

[244] 文件: include/ScopInfo.h : 第 1649 行
------------------------------------------------------------
Isl context.

We need a shared_ptr with reference counter to delete the context when all
isl objects are deleted. We will distribute the shared_ptr to all objects
that use the context to create isl objects, and increase the reference
counter. By doing this, we guarantee that the context is deleted when we
delete the last object that creates isl objects with the context. This
declaration needs to be the first in class to gracefully destroy all isl
objects before the context.

================================================================================

[245] 文件: include/ScopInfo.h : 第 1730 行
------------------------------------------------------------
A map to remember ScopArrayInfo objects for all base pointers.

As PHI nodes may have two array info objects associated, we add a flag
that distinguishes between the PHI node specific ArrayInfo object
and the normal one.

================================================================================

[246] 文件: include/ScopInfo.h : 第 1745 行
------------------------------------------------------------
The assumptions under which this scop was built.

When constructing a scop sometimes the exact representation of a statement
or condition would be very complex, but there is a common case which is a
lot simpler, but which is only valid under certain assumptions. The
assumed context records the assumptions taken during the construction of
this scop and that need to be code generated as a run-time test.

================================================================================

[247] 文件: include/ScopInfo.h : 第 1754 行
------------------------------------------------------------
The restrictions under which this SCoP was built.

The invalid context is similar to the assumed context as it contains
constraints over the parameters. However, while we need the constraints
in the assumed context to be "true" the constraints in the invalid context
need to be "false". Otherwise they behave the same.

================================================================================

[248] 文件: include/ScopInfo.h : 第 1762 行
------------------------------------------------------------
The context under which the SCoP must have defined behavior. Optimizer and
code generator can assume that the SCoP will only be executed with
parameter values within this context. This might be either because we can
prove that other values are impossible or explicitly have undefined
behavior, such as due to no-wrap flags. If this becomes too complex, can
also be nullptr.

In contrast to Scop::AssumedContext and Scop::InvalidContext, these do not
need to be checked at runtime.

Scop::Context on the other side is an overapproximation and does not
include all requirements, but is always defined. However, there is still
no guarantee that there is no undefined behavior in
DefinedBehaviorContext.

================================================================================

[249] 文件: include/ScopInfo.h : 第 1778 行
------------------------------------------------------------
The schedule of the SCoP

The schedule of the SCoP describes the execution order of the statements
in the scop by assigning each statement instance a possibly
multi-dimensional execution time. The schedule is stored as a tree of
schedule nodes.

The most common nodes in a schedule tree are so-called band nodes. Band
nodes map statement instances into a multi dimensional schedule space.
This space can be seen as a multi-dimensional clock.

Example:

<S,(5,4)>  may be mapped to (5,4) by this schedule:

s0 = i (Year of execution)
s1 = j (Day of execution)

or to (9, 20) by this schedule:

s0 = i + j (Year of execution)
s1 = 20 (Day of execution)

The order statement instances are executed is defined by the
schedule vectors they are mapped to. A statement instance
<A, (i, j, ..)> is executed before a statement instance <B, (i', ..)>, if
the schedule vector of A is lexicographic smaller than the schedule
vector of B.

Besides band nodes, schedule trees contain additional nodes that specify
a textual ordering between two subtrees or filter nodes that filter the
set of statement instances that will be scheduled in a subtree. There
are also several other nodes. A full description of the different nodes
in a schedule tree is given in the isl manual.

================================================================================

[250] 文件: include/ScopInfo.h : 第 1821 行
------------------------------------------------------------
The set of minimal/maximal accesses for each alias group.

When building runtime alias checks we look at all memory instructions and
build so called alias groups. Each group contains a set of accesses to
different base arrays which might alias with each other. However, between
alias groups there is no aliasing possible.

In a program with int and float pointers annotated with tbaa information
we would probably generate two alias groups, one for the int pointers and
one for the float pointers.

During code generation we will create a runtime alias check for each alias
group to ensure the SCoP is executed in an alias free environment.

================================================================================

[251] 文件: include/ScopInfo.h : 第 1891 行
------------------------------------------------------------
Create a new SCoP statement for @p BB.

A new statement for @p BB will be created and added to the statement
vector
and map.

@param BB              The basic block we build the statement for.
@param Name            The name of the new statement.
@param SurroundingLoop The loop the created statement is contained in.
@param Instructions    The instructions in the statement.

================================================================================

[252] 文件: include/ScopInfo.h : 第 1904 行
------------------------------------------------------------
Create a new SCoP statement for @p R.

A new statement for @p R will be created and added to the statement vector
and map.

@param R                      The region we build the statement for.
@param Name                   The name of the new statement.
@param SurroundingLoop        The loop the created statement is contained
                              in.
@param EntryBlockInstructions The (interesting) instructions in the
                              entry block of the region statement.

================================================================================

[253] 文件: include/ScopInfo.h : 第 1925 行
------------------------------------------------------------
Collect all memory access relations of a given type.

@param Predicate A predicate function that returns true if an access is
                 of a given type.

@returns The set of memory accesses in the scop that match the predicate.

================================================================================

[254] 文件: include/ScopInfo.h : 第 1948 行
------------------------------------------------------------
Increment actual number of aliasing assumptions taken

@param Step    Number of new aliasing assumptions which should be added to
the number of already taken assumptions.

================================================================================

[255] 文件: include/ScopInfo.h : 第 1959 行
------------------------------------------------------------
Create a new copy statement.

A new statement will be created and added to the statement vector.

@param SourceRel  The source location.
@param TargetRel  The target location.
@param Domain     The original domain under which the copy statement would
                  be executed.

================================================================================

[256] 文件: include/ScopInfo.h : 第 2078 行
------------------------------------------------------------
Return the isl_id that represents a certain parameter.

@param Parameter A SCEV that was recognized as a Parameter.

@return The corresponding isl_id or NULL otherwise.

================================================================================

[257] 文件: include/ScopInfo.h : 第 2149 行
------------------------------------------------------------
Get the name of the entry and exit blocks of this Scop.

These along with the function name can uniquely identify a Scop.

@return std::pair whose first element is the entry name & second element
        is the exit name.

================================================================================

[258] 文件: include/ScopInfo.h : 第 2178 行
------------------------------------------------------------
Return space of isl context parameters.

Returns the set of context parameters that are currently constrained. In
case the full set of parameters is needed, see @getFullParamSpace.

================================================================================

[259] 文件: include/ScopInfo.h : 第 2184 行
------------------------------------------------------------
Return the full space of parameters.

getParamSpace will only return the parameters of the context that are
actually constrained, whereas getFullParamSpace will return all

================================================================================

[260] 文件: include/ScopInfo.h : 第 2198 行
------------------------------------------------------------
Return true if the optimized SCoP can be executed.

In addition to the runtime check context this will also utilize the domain
constraints to decide it the optimized version can actually be executed.

@returns True if the optimized SCoP can be executed.

================================================================================

[261] 文件: include/ScopInfo.h : 第 2206 行
------------------------------------------------------------
Check if the assumption in @p Set is trivial or not.

@param Set  The relations between parameters that are assumed to hold.
@param Sign Enum to indicate if the assumptions in @p Set are positive
            (needed/assumptions) or negative (invalid/restrictions).

@returns True if the assumption @p Set is not trivial.

================================================================================

[262] 文件: include/ScopInfo.h : 第 2215 行
------------------------------------------------------------
Track and report an assumption.

Use 'clang -Rpass-analysis=polly-scops' or 'opt
-pass-remarks-analysis=polly-scops' to output the assumptions.

@param Kind The assumption kind describing the underlying cause.
@param Set  The relations between parameters that are assumed to hold.
@param Loc  The location in the source that caused this assumption.
@param Sign Enum to indicate if the assumptions in @p Set are positive
            (needed/assumptions) or negative (invalid/restrictions).
@param BB   The block in which this assumption was taken. Used to
            calculate hotness when emitting remark.

@returns True if the assumption is not trivial.

================================================================================

[263] 文件: include/ScopInfo.h : 第 2236 行
------------------------------------------------------------
Add assumptions to assumed context.

The assumptions added will be assumed to hold during the execution of the
scop. However, as they are generally not statically provable, at code
generation time run-time checks will be generated that ensure the
assumptions hold.

WARNING: We currently exploit in simplifyAssumedContext the knowledge
         that assumptions do not change the set of statement instances
         executed.

@param Kind The assumption kind describing the underlying cause.
@param Set  The relations between parameters that are assumed to hold.
@param Loc  The location in the source that caused this assumption.
@param Sign Enum to indicate if the assumptions in @p Set are positive
            (needed/assumptions) or negative (invalid/restrictions).
@param BB   The block in which this assumption was taken. Used to
            calculate hotness when emitting remark.
@param RTC  Does the assumption require a runtime check?

================================================================================

[264] 文件: include/ScopInfo.h : 第 2258 行
------------------------------------------------------------
Mark the scop as invalid.

This method adds an assumption to the scop that is always invalid. As a
result, the scop will not be optimized later on. This function is commonly
called when a condition makes it impossible (or too compile time
expensive) to process this scop any further.

@param Kind The assumption kind describing the underlying cause.
@param Loc  The location in the source that triggered .
@param BB   The BasicBlock where it was triggered.

================================================================================

[265] 文件: include/ScopInfo.h : 第 2290 行
------------------------------------------------------------
Remove statements from the list of scop statements.

@param ShouldDelete  A function that returns true if the statement passed
                     to it should be deleted.
@param AfterHoisting If true, also remove from data access lists.
                     These lists are filled during
                     ScopBuilder::buildAccessRelations. Therefore, if this
                     method is called before buildAccessRelations, false
                     must be passed.

================================================================================

[266] 文件: include/ScopInfo.h : 第 2319 行
------------------------------------------------------------
Return the last statement representing @p BB.

Of the sequence of statements that represent a @p BB, this is the last one
to be executed. It is typically used to determine which instruction to add
a MemoryKind::PHI WRITE to. For this purpose, it is not strictly required
to be executed last, only that the incoming value is available in it.

================================================================================

[267] 文件: include/ScopInfo.h : 第 2384 行
------------------------------------------------------------
Return the (possibly new) ScopArrayInfo object for @p Access.

@param ElementType The type of the elements stored in this array.
@param Kind        The kind of the array info object.
@param BaseName    The optional name of this memory reference.

================================================================================

[268] 文件: include/ScopInfo.h : 第 2394 行
------------------------------------------------------------
Create an array and return the corresponding ScopArrayInfo object.

@param ElementType The type of the elements stored in this array.
@param BaseName    The name of this memory reference.
@param Sizes       The sizes of dimensions.

================================================================================

[269] 文件: include/ScopInfo.h : 第 2403 行
------------------------------------------------------------
Return the cached ScopArrayInfo object for @p BasePtr.

@param BasePtr   The base pointer the object has been stored for.
@param Kind      The kind of array info object.

@returns The ScopArrayInfo pointer or NULL if no such pointer is
         available.

================================================================================

[270] 文件: include/ScopInfo.h : 第 2412 行
------------------------------------------------------------
Return the cached ScopArrayInfo object for @p BasePtr.

@param BasePtr   The base pointer the object has been stored for.
@param Kind      The kind of array info object.

@returns The ScopArrayInfo pointer (may assert if no such pointer is
         available).

================================================================================

[271] 文件: include/ScopInfo.h : 第 2421 行
------------------------------------------------------------
Invalidate ScopArrayInfo object for base address.

@param BasePtr The base pointer of the ScopArrayInfo object to invalidate.
@param Kind    The Kind of the ScopArrayInfo object.

================================================================================

[272] 文件: include/ScopInfo.h : 第 2445 行
------------------------------------------------------------
Return true if this SCoP can be profitably optimized.

@param ScalarsAreUnprofitable Never consider statements with scalar writes
                              as profitably optimizable.

@return Whether this SCoP can be profitably optimized.

================================================================================

[273] 文件: include/ScopInfo.h : 第 2462 行
------------------------------------------------------------
Print the static control part.

@param OS The output stream the static control part is printed to.
@param PrintInstructions Whether to print the statement's instructions as
                         well.

================================================================================

[274] 文件: include/ScopInfo.h : 第 2482 行
------------------------------------------------------------
Compute the isl representation for the SCEV @p E

@param E  The SCEV that should be translated.
@param BB An (optional) basic block in which the isl_pw_aff is computed.
          SCEVs known to not reference any loops in the SCoP can be
          passed without a @p BB.
@param NonNegative Flag to indicate the @p E has to be non-negative.

Note that this function will always return a valid isl_pw_aff. However, if
the translation of @p E was deemed to complex the SCoP is invalidated and
a dummy value of appropriate dimension is returned. This allows to bail
for complex cases without "error handling code" needed on the users side.

================================================================================

[275] 文件: include/ScopInfo.h : 第 2498 行
------------------------------------------------------------
Compute the isl representation for the SCEV @p E

This function is like @see Scop::getPwAff() but strips away the invalid
domain part associated with the piecewise affine function.

================================================================================

[276] 文件: include/ScopInfo.h : 第 2551 行
------------------------------------------------------------
Get the schedule of all the statements in the SCoP.

@return The schedule of all the statements in the SCoP, if the schedule of
the Scop does not contain extension nodes, and nullptr, otherwise.

================================================================================

[277] 文件: include/ScopInfo.h : 第 2579 行
------------------------------------------------------------
Get the depth of a loop relative to the outermost loop in the Scop.

This will return
   0 if @p L is an outermost loop in the SCoP
  >0 for other loops in the SCoP
  -1 if @p L is nullptr or there is no outermost loop in the SCoP

================================================================================

[278] 文件: include/ScopInfo.h : 第 2591 行
------------------------------------------------------------
Simplify the SCoP representation.

@param AfterHoisting Whether it is called after invariant load hoisting.
                     When true, also removes statements without
                     side-effects.

================================================================================

[279] 文件: include/ScopInfo.h : 第 2598 行
------------------------------------------------------------
Get the next free array index.

This function returns a unique index which can be used to identify an
array.

================================================================================

[280] 文件: include/ScopInfo.h : 第 2604 行
------------------------------------------------------------
Get the next free statement index.

This function returns a unique index which can be used to identify a
statement.

================================================================================

[281] 文件: include/ScopInfo.h : 第 2610 行
------------------------------------------------------------
Get the representing SCEV for @p S if applicable, otherwise @p S.

Invariant loads of the same location are put in an equivalence class and
only one of them is chosen as a representing element that will be
modeled as a parameter. The others have to be normalized, i.e.,
replaced by the representing element of their equivalence class, in order
to get the correct parameter value, e.g., in the SCEVAffinator.

@param S The SCEV to normalize.

@return The representing SCEV for invariant loads or @p S if none.

================================================================================

[282] 文件: include/ScopInfo.h : 第 2623 行
------------------------------------------------------------
Return the MemoryAccess that writes an llvm::Value, represented by a
ScopArrayInfo.

There can be at most one such MemoryAccess per llvm::Value in the SCoP.
Zero is possible for read-only values.

================================================================================

[283] 文件: include/ScopInfo.h : 第 2634 行
------------------------------------------------------------
Return the MemoryAccess that represents an llvm::PHINode.

ExitPHIs's PHINode is not within the SCoPs. This function returns nullptr
for them.

================================================================================

[284] 文件: include/ScopInfo.h : 第 2659 行
------------------------------------------------------------
Collect statistic about this SCoP.

These are most commonly used for LLVM's static counters (Statistic.h) in
various places. If statistics are disabled, only zeros are returned to
avoid the overhead.

================================================================================

[285] 文件: include/ScopInfo.h : 第 2689 行
------------------------------------------------------------
Build Scop object, the Polly IR of static control
       part for the current SESE-Region.

@return If the current region is a valid for a static control part,
        return the Polly IR representing this static control part,
        return null otherwise.

================================================================================

[286] 文件: include/ScopInfo.h : 第 2736 行
------------------------------------------------------------
Get the Scop object for the given Region.

@return If the given region is the maximal region within a scop, return
        the scop object. If the given region is a subregion, return a
        nullptr. Top level region containing the entry block of a function
        is not considered in the scop creation.

================================================================================

[287] 文件: include/ScopInfo.h : 第 2786 行
------------------------------------------------------------
The legacy pass manager's analysis pass to compute scop information
       for the whole function.

This pass will maintain a map of the maximal region within a scop to its
scop object for all the feasible scops present in a function.
This pass is an alternative to the ScopInfoRegionPass in order to avoid a
region pass manager.

================================================================================

[288] 文件: include/ScopBuilder.h : 第 65 行
------------------------------------------------------------
Collection to hold taken assumptions.

There are two reasons why we want to record assumptions first before we
add them to the assumed/invalid context:
  1) If the SCoP is not profitable or otherwise invalid without the
     assumed/invalid context we do not have to compute it.
  2) Information about the context are gathered rather late in the SCoP
     construction (basically after we know all parameters), thus the user
     might see overly complicated assumptions to be taken while they will
     only be simplified later on.

================================================================================

[289] 文件: include/ScopBuilder.h : 第 80 行
------------------------------------------------------------
Adjust the dimensions of @p Dom that was constructed for @p OldL
       to be compatible to domains constructed for loop @p NewL.

This function assumes @p NewL and @p OldL are equal or there is a CFG
edge from @p OldL to @p NewL.

================================================================================

[290] 文件: include/ScopBuilder.h : 第 87 行
------------------------------------------------------------
Compute the domain for each basic block in @p R.

@param R                The region we currently traverse.
@param InvalidDomainMap BB to InvalidDomain map for the BB of current
                        region.

@returns True if there was no problem and false otherwise.

================================================================================

[291] 文件: include/ScopBuilder.h : 第 97 行
------------------------------------------------------------
Compute the branching constraints for each basic block in @p R.

@param R                The region we currently build branching conditions
                        for.
@param InvalidDomainMap BB to InvalidDomain map for the BB of current
                        region.

@returns True if there was no problem and false otherwise.

================================================================================

[292] 文件: include/ScopBuilder.h : 第 108 行
------------------------------------------------------------
Build the conditions sets for the terminator @p TI in the @p Domain.

This will fill @p ConditionSets with the conditions under which control
will be moved from @p TI to its successors. Hence, @p ConditionSets will
have as many elements as @p TI has successors.

================================================================================

[293] 文件: include/ScopBuilder.h : 第 118 行
------------------------------------------------------------
Build the conditions sets for the branch condition @p Condition in
the @p Domain.

This will fill @p ConditionSets with the conditions under which control
will be moved from @p TI to its successors. Hence, @p ConditionSets will
have as many elements as @p TI has successors. If @p TI is nullptr the
context under which @p Condition is true/false will be returned as the
new elements of @p ConditionSets.

================================================================================

[294] 文件: include/ScopBuilder.h : 第 131 行
------------------------------------------------------------
Build the conditions sets for the switch @p SI in the @p Domain.

This will fill @p ConditionSets with the conditions under which control
will be moved from @p SI to its successors. Hence, @p ConditionSets will
have as many elements as @p SI has successors.

================================================================================

[295] 文件: include/ScopBuilder.h : 第 141 行
------------------------------------------------------------
Build condition sets for unsigned ICmpInst(s).
Special handling is required for unsigned operands to ensure that if
MSB (aka the Sign bit) is set for an operands in an unsigned ICmpInst
it should wrap around.

@param IsStrictUpperBound holds information on the predicate relation
between TestVal and UpperBound, i.e,
TestVal < UpperBound  OR  TestVal <= UpperBound

================================================================================

[296] 文件: include/ScopBuilder.h : 第 155 行
------------------------------------------------------------
Propagate the domain constraints through the region @p R.

@param R                The region we currently build branching
conditions for.
@param InvalidDomainMap BB to InvalidDomain map for the BB of current
                        region.

@returns True if there was no problem and false otherwise.

================================================================================

[297] 文件: include/ScopBuilder.h : 第 166 行
------------------------------------------------------------
Propagate domains that are known due to graph properties.

As a CFG is mostly structured we use the graph properties to propagate
domains without the need to compute all path conditions. In particular,
if a block A dominates a block B and B post-dominates A we know that the
domain of B is a superset of the domain of A. As we do not have
post-dominator information available here we use the less precise region
information. Given a region R, we know that the exit is always executed
if the entry was executed, thus the domain of the exit is a superset of
the domain of the entry. In case the exit can only be reached from
within the region the domains are in fact equal. This function will use
this property to avoid the generation of condition constraints that
determine when a branch is taken. If @p BB is a region entry block we
will propagate its domain to the region exit block. Additionally, we put
the region exit block in the @p FinishedExitBlocks set so we can later
skip edges from within the region to that block.

@param BB                 The block for which the domain is currently
                          propagated.
@param BBLoop             The innermost affine loop surrounding @p BB.
@param FinishedExitBlocks Set of region exits the domain was set for.
@param InvalidDomainMap   BB to InvalidDomain map for the BB of current
                          region.

================================================================================

[298] 文件: include/ScopBuilder.h : 第 194 行
------------------------------------------------------------
Propagate invalid domains of statements through @p R.

This method will propagate invalid statement domains through @p R and at
the same time add error block domains to them. Additionally, the domains
of error statements and those only reachable via error statements will
be replaced by an empty set. Later those will be removed completely.

@param R                The currently traversed region.
@param InvalidDomainMap BB to InvalidDomain map for the BB of current
                        region.

================================================================================

[299] 文件: include/ScopBuilder.h : 第 209 行
------------------------------------------------------------
Compute the union of predecessor domains for @p BB.

To compute the union of all domains of predecessors of @p BB this
function applies similar reasoning on the CFG structure as described for
  @see propagateDomainConstraintsToRegionExit

@param BB     The block for which the predecessor domains are collected.
@param Domain The domain under which BB is executed.

@returns The domain under which @p BB is executed.

================================================================================

[300] 文件: include/ScopBuilder.h : 第 221 行
------------------------------------------------------------
Add loop carried constraints to the header block of the loop @p L.

@param L                The loop to process.
@param InvalidDomainMap BB to InvalidDomain map for the BB of current
                        region.

@returns True if there was no problem and false otherwise.

================================================================================

[301] 文件: include/ScopBuilder.h : 第 231 行
------------------------------------------------------------
Compute the isl representation for the SCEV @p E in this BB.

@param BB               The BB for which isl representation is to be
computed.
@param InvalidDomainMap A map of BB to their invalid domains.
@param E                The SCEV that should be translated.
@param NonNegative      Flag to indicate the @p E has to be
non-negative.

Note that this function will also adjust the invalid context
accordingly.

================================================================================

[302] 文件: include/ScopBuilder.h : 第 246 行
------------------------------------------------------------
Create equivalence classes for required invariant accesses.

These classes will consolidate multiple required invariant loads from the
same address in order to keep the number of dimensions in the SCoP
description small. For each such class equivalence class only one
representing element, hence one required invariant load, will be chosen
and modeled as parameter. The method
Scop::getRepresentingInvariantLoadSCEV() will replace each element from an
equivalence class with the representing element that is modeled. As a
consequence Scop::getIdForParam() will only return an id for the
representing element of each equivalence class, thus for each required
invariant location.

================================================================================

[303] 文件: include/ScopBuilder.h : 第 260 行
------------------------------------------------------------
Try to build a multi-dimensional fixed sized MemoryAccess from the
Load/Store instruction.

@param Inst       The Load/Store instruction that access the memory
@param Stmt       The parent statement of the instruction

@returns True if the access could be built, False otherwise.

================================================================================

[304] 文件: include/ScopBuilder.h : 第 269 行
------------------------------------------------------------
Try to build a multi-dimensional parametric sized MemoryAccess.
       from the Load/Store instruction.

@param Inst       The Load/Store instruction that access the memory
@param Stmt       The parent statement of the instruction

@returns True if the access could be built, False otherwise.

================================================================================

[305] 文件: include/ScopBuilder.h : 第 278 行
------------------------------------------------------------
Try to build a MemoryAccess for a memory intrinsic.

@param Inst       The instruction that access the memory
@param Stmt       The parent statement of the instruction

@returns True if the access could be built, False otherwise.

================================================================================

[306] 文件: include/ScopBuilder.h : 第 286 行
------------------------------------------------------------
Try to build a MemoryAccess for a call instruction.

@param Inst       The call instruction that access the memory
@param Stmt       The parent statement of the instruction

@returns True if the access could be built, False otherwise.

================================================================================

[307] 文件: include/ScopBuilder.h : 第 294 行
------------------------------------------------------------
Build a single-dimensional parametric sized MemoryAccess
       from the Load/Store instruction.

@param Inst       The Load/Store instruction that access the memory
@param Stmt       The parent statement of the instruction

@returns True if the access could be built, False otherwise.

================================================================================

[308] 文件: include/ScopBuilder.h : 第 303 行
------------------------------------------------------------
Finalize all access relations.

When building up access relations, temporary access relations that
correctly represent each individual access are constructed. However, these
access relations can be inconsistent or non-optimal when looking at the
set of accesses as a whole. This function finalizes the memory accesses
and constructs a globally consistent state.

================================================================================

[309] 文件: include/ScopBuilder.h : 第 312 行
------------------------------------------------------------
Update access dimensionalities.

When detecting memory accesses different accesses to the same array may
have built with different dimensionality, as outer zero-values dimensions
may not have been recognized as separate dimensions. This function goes
again over all memory accesses and updates their dimensionality to match
the dimensionality of the underlying ScopArrayInfo object.

================================================================================

[310] 文件: include/ScopBuilder.h : 第 321 行
------------------------------------------------------------
Fold size constants to the right.

In case all memory accesses in a given dimension are multiplied with a
common constant, we can remove this constant from the individual access
functions and move it to the size of the memory access. We do this as this
increases the size of the innermost dimension, consequently widens the
valid range the array subscript in this dimension can evaluate to, and
as a result increases the likelihood that our delinearization is
correct.

Example:

   A[][n]
   S[i,j] -> A[2i][2j+1]
   S[i,j] -> A[2i][2j]

   =>

   A[][2n]
   S[i,j] -> A[i][2j+1]
   S[i,j] -> A[i][2j]

Constants in outer dimensions can arise when the elements of a parametric
multi-dimensional array are not elementary data types, but e.g.,
structures.

================================================================================

[311] 文件: include/ScopBuilder.h : 第 348 行
------------------------------------------------------------
Fold memory accesses to handle parametric offset.

As a post-processing step, we 'fold' memory accesses to parametric
offsets in the access functions. @see MemoryAccess::foldAccess for
details.

================================================================================

[312] 文件: include/ScopBuilder.h : 第 355 行
------------------------------------------------------------
Assume that all memory accesses are within bounds.

After we have built a model of all memory accesses, we need to assume
that the model we built matches reality -- aka. all modeled memory
accesses always remain within bounds. We do this as last step, after
all memory accesses have been modeled and canonicalized.

================================================================================

[313] 文件: include/ScopBuilder.h : 第 372 行
------------------------------------------------------------
Build a given alias group and its access data.

@param AliasGroup     The alias group to build.
@param HasWriteAccess A set of arrays through which memory is not only
                      read, but also written.

================================================================================

[314] 文件: include/ScopBuilder.h : 第 387 行
------------------------------------------------------------
Build alias groups for all memory accesses in the Scop.

Using the alias analysis and an alias set tracker we build alias sets
for all memory accesses inside the Scop. For each alias set we then map
the aliasing pointers back to the memory accesses we know, thus obtain
groups of memory accesses which might alias. We also collect the set of
arrays through which memory is written.

@returns A pair consistent of a vector of alias groups and a set of arrays
         through which memory is written.

================================================================================

[315] 文件: include/ScopBuilder.h : 第 400 行
------------------------------------------------------------
 Split alias groups by iteration domains.

 We split each group based on the domains of the minimal/maximal accesses.
 That means two minimal/maximal accesses are only in a group if their
 access domains intersect. Otherwise, they are in different groups.

 @param AliasGroups The alias groups to split

================================================================================

[316] 文件: include/ScopBuilder.h : 第 409 行
------------------------------------------------------------
Build an instance of MemoryAccess from the Load/Store instruction.

@param Inst       The Load/Store instruction that access the memory
@param Stmt       The parent statement of the instruction

================================================================================

[317] 文件: include/ScopBuilder.h : 第 415 行
------------------------------------------------------------
Analyze and extract the cross-BB scalar dependences (or, dataflow
dependencies) of an instruction.

@param UserStmt The statement @p Inst resides in.
@param Inst     The instruction to be analyzed.

================================================================================

[318] 文件: include/ScopBuilder.h : 第 422 行
------------------------------------------------------------
Build the escaping dependences for @p Inst.

Search for uses of the llvm::Value defined by @p Inst that are not
within the SCoP. If there is such use, add a SCALAR WRITE such that
it is available after the SCoP as escaping value.

@param Inst The instruction to be analyzed.

================================================================================

[319] 文件: include/ScopBuilder.h : 第 431 行
------------------------------------------------------------
Create MemoryAccesses for the given PHI node in the given region.

@param PHIStmt            The statement @p PHI resides in.
@param PHI                The PHI node to be handled
@param NonAffineSubRegion The non affine sub-region @p PHI is in.
@param IsExitBlock        Flag to indicate that @p PHI is in the exit BB.

================================================================================

[320] 文件: include/ScopBuilder.h : 第 443 行
------------------------------------------------------------
Should an instruction be modeled in a ScopStmt.

@param Inst The instruction to check.
@param L    The loop in which context the instruction is looked at.

@returns True if the instruction should be modeled.

================================================================================

[321] 文件: include/ScopBuilder.h : 第 451 行
------------------------------------------------------------
Create one or more ScopStmts for @p BB.

Consecutive instructions are associated to the same statement until a
separator is found.

================================================================================

[322] 文件: include/ScopBuilder.h : 第 457 行
------------------------------------------------------------
Create one or more ScopStmts for @p BB using equivalence classes.

Instructions of a basic block that belong to the same equivalence class
are added to the same statement.

================================================================================

[323] 文件: include/ScopBuilder.h : 第 463 行
------------------------------------------------------------
Create ScopStmt for all BBs and non-affine subregions of @p SR.

@param SR A subregion of @p R.

Some of the statements might be optimized away later when they do not
access any memory and thus have no effect.

================================================================================

[324] 文件: include/ScopBuilder.h : 第 471 行
------------------------------------------------------------
Build the access functions for the statement @p Stmt in or represented by
@p BB.

@param Stmt               Statement to add MemoryAccesses to.
@param BB                 A basic block in @p R.
@param NonAffineSubRegion The non affine sub-region @p BB is in.

================================================================================

[325] 文件: include/ScopBuilder.h : 第 480 行
------------------------------------------------------------
Create a new MemoryAccess object and add it to #AccFuncMap.

@param Stmt        The statement where the access takes place.
@param Inst        The instruction doing the access. It is not necessarily
                   inside @p BB.
@param AccType     The kind of access.
@param BaseAddress The accessed array's base address.
@param ElemType    The type of the accessed array elements.
@param Affine      Whether all subscripts are affine expressions.
@param AccessValue Value read or written.
@param Subscripts  Access subscripts per dimension.
@param Sizes       The array dimension's sizes.
@param Kind        The kind of memory accessed.

@return The created MemoryAccess, or nullptr if the access is not within
        the SCoP.

================================================================================

[326] 文件: include/ScopBuilder.h : 第 503 行
------------------------------------------------------------
Create a MemoryAccess that represents either a LoadInst or
StoreInst.

@param Stmt        The statement to add the MemoryAccess to.
@param MemAccInst  The LoadInst or StoreInst.
@param AccType     The kind of access.
@param BaseAddress The accessed array's base address.
@param ElemType    The type of the accessed array elements.
@param IsAffine    Whether all subscripts are affine expressions.
@param Subscripts  Access subscripts per dimension.
@param Sizes       The array dimension's sizes.
@param AccessValue Value read or written.

@see MemoryKind

================================================================================

[327] 文件: include/ScopBuilder.h : 第 523 行
------------------------------------------------------------
Create a MemoryAccess for writing an llvm::Instruction.

The access will be created at the position of @p Inst.

@param Inst The instruction to be written.

@see ensureValueRead()
@see MemoryKind

================================================================================

[328] 文件: include/ScopBuilder.h : 第 533 行
------------------------------------------------------------
Ensure an llvm::Value is available in the BB's statement, creating a
MemoryAccess for reloading it if necessary.

@param V        The value expected to be loaded.
@param UserStmt Where to reload the value.

@see ensureValueStore()
@see MemoryKind

================================================================================

[329] 文件: include/ScopBuilder.h : 第 543 行
------------------------------------------------------------
Create a write MemoryAccess for the incoming block of a phi node.

Each of the incoming blocks write their incoming value to be picked in the
phi's block.

@param PHI           PHINode under consideration.
@param IncomingStmt  The statement to add the MemoryAccess to.
@param IncomingBlock Some predecessor block.
@param IncomingValue @p PHI's value when coming from @p IncomingBlock.
@param IsExitBlock   When true, uses the .s2a alloca instead of the
                     .phiops one. Required for values escaping through a
                     PHINode in the SCoP region's exit block.
@see addPHIReadAccess()
@see MemoryKind

================================================================================

[330] 文件: include/ScopBuilder.h : 第 571 行
------------------------------------------------------------
Create a MemoryAccess for reading the value of a phi.

The modeling assumes that all incoming blocks write their incoming value
to the same location. Thus, this access will read the incoming block's
value as instructed by this @p PHI.

@param PHIStmt Statement @p PHI resides in.
@param PHI     PHINode under consideration; the READ access will be added
               here.

@see ensurePHIWrite()
@see MemoryKind

================================================================================

[331] 文件: include/ScopBuilder.h : 第 594 行
------------------------------------------------------------
Check for reductions in @p Stmt.

Iterate over all store memory accesses and check for valid binary
reduction like chains. For all candidates we check if they have the same
base address and there are no other accesses which overlap with them. The
base address check rules out impossible reductions candidates early. The
overlap check, together with the "only one user" check in
collectCandidateReductionLoads, guarantees that none of the intermediate
results will escape during execution of the loop nest. We basically check
here that no other memory access can access the same memory as the
potential reduction.

================================================================================

[332] 文件: include/ScopBuilder.h : 第 607 行
------------------------------------------------------------
Verify that all required invariant loads have been hoisted.

Invariant load hoisting is not guaranteed to hoist all loads that were
assumed to be scop invariant during scop detection. This function checks
for cases where the hoisting failed, but where it would have been
necessary for our scop modeling to be correct. In case of insufficient
hoisting the scop is marked as invalid.

In the example below Bound[1] is required to be invariant:

for (int i = 1; i < Bound[0]; i++)
  for (int j = 1; j < Bound[1]; j++)
    ...

================================================================================

[333] 文件: include/ScopBuilder.h : 第 622 行
------------------------------------------------------------
Hoist invariant memory loads and check for required ones.

We first identify "common" invariant loads, thus loads that are invariant
and can be hoisted. Then we check if all required invariant loads have
been identified as (common) invariant. A load is a required invariant load
if it was assumed to be invariant during SCoP detection, e.g., to assume
loop bounds to be affine or runtime alias checks to be placeable. In case
a required invariant load was not identified as (common) invariant we will
drop this SCoP. An example for both "common" as well as required invariant
loads is given below:

for (int i = 1; i < *LB[0]; i++)
  for (int j = 1; j < *LB[1]; j++)
    A[i][j] += A[0][0] + (*V);

Common inv. loads: V, A[0][0], LB[0], LB[1]
Required inv. loads: LB[0], LB[1], (V, if it may alias with A or LB)

================================================================================

[334] 文件: include/ScopBuilder.h : 第 657 行
------------------------------------------------------------
Return the context under which the access cannot be hoisted.

@param Access The access to check.
@param Writes The set of all memory writes in the scop.

@return Return the context under which the access cannot be hoisted or a
        nullptr if it cannot be hoisted at all.

================================================================================

[335] 文件: include/ScopBuilder.h : 第 669 行
------------------------------------------------------------
Canonicalize arrays with base pointers from the same equivalence class.

Some context: in our normal model we assume that each base pointer is
related to a single specific memory region, where memory regions
associated with different base pointers are disjoint. Consequently we do
not need to compute additional data dependences that model possible
overlaps of these memory regions. To verify our assumption we compute
alias checks that verify that modeled arrays indeed do not overlap. In
case an overlap is detected the runtime check fails and we fall back to
the original code.

In case of arrays where the base pointers are know to be identical,
because they are dynamically loaded by accesses that are in the same
invariant load equivalence class, such run-time alias check would always
be false.

This function makes sure that we do not generate consistently failing
run-time checks for code that contains distinct arrays with known
equivalent base pointers. It identifies for each invariant load
equivalence class a single canonical array and canonicalizes all memory
accesses that reference arrays that have base pointers that are known to
be equal to the base pointer of such a canonical array to this canonical
array.

We currently do not canonicalize arrays for which certain memory accesses
have been hoisted as loop invariant.

================================================================================

[336] 文件: include/ScopBuilder.h : 第 717 行
------------------------------------------------------------
The loop stack used for schedule construction.

The loop stack keeps track of schedule information for a set of nested
loops as well as an (optional) 'nullptr' loop that models the outermost
schedule dimension. The loops in a loop stack always have a parent-child
relation where the loop at position n is the parent of the loop at
position n + 1.

================================================================================

[337] 文件: include/ScopBuilder.h : 第 726 行
------------------------------------------------------------
Construct schedule information for a given Region and add the
       derived information to @p LoopStack.

Given a Region we derive schedule information for all RegionNodes
contained in this region ensuring that the assigned execution times
correctly model the existing control flow relations.

@param R              The region which to process.
@param LoopStack      A stack of loops that are currently under
                      construction.

================================================================================

[338] 文件: include/ScopBuilder.h : 第 738 行
------------------------------------------------------------
Build Schedule for the region node @p RN and add the derived
       information to @p LoopStack.

In case @p RN is a BasicBlock or a non-affine Region, we construct the
schedule for this @p RN and also finalize loop schedules in case the
current @p RN completes the loop.

In case @p RN is a not-non-affine Region, we delegate the construction to
buildSchedule(Region *R, ...).

@param RN             The RegionNode region traversed.
@param LoopStack      A stack of loops that are currently under
                      construction.

================================================================================

[339] 文件: include/ScopBuilder.h : 第 762 行
------------------------------------------------------------
Try to build the Polly IR of static control part on the current
SESE-Region.

@return Give up the ownership of the scop object or static control part
        for the region

================================================================================

[340] 文件: include/ManualOptimizer.h : 第 26 行
------------------------------------------------------------
Apply loop-transformation metadata.

The loop metadata are taken from mark-nodes in @sched. These nodes have been
added by ScopBuilder when creating a schedule for a loop with an attach
LoopID.

@param S     The SCoP for @p Sched.
@param Sched The input schedule to apply the directives on.

@return The transformed schedule with all mark-nodes with loop
        transformations applied. Returns NULL in case of an error or @p
        Sched itself if no transformation has been applied.

================================================================================

[341] 文件: include/ScheduleTreeTransform.h : 第 157 行
------------------------------------------------------------
Recursively visit all nodes of a schedule tree while allowing changes.

The visit methods return an isl::schedule_node that is used to continue
visiting the tree. Structural changes such as returning a different node
will confuse the visitor.

================================================================================

[342] 文件: include/ScheduleTreeTransform.h : 第 198 行
------------------------------------------------------------
Hoist all domains from extension into the root domain node, such that there
are no more extension nodes (which isl does not support for some
operations). This assumes that domains added by to extension nodes do not
overlap.

================================================================================

[343] 文件: include/ScheduleTreeTransform.h : 第 204 行
------------------------------------------------------------
Replace the AST band @p BandToUnroll by a sequence of all its iterations.

The implementation enumerates all points in the partial schedule and creates
an ISL sequence node for each point. The number of iterations must be a
constant.

================================================================================

[344] 文件: include/ScheduleTreeTransform.h : 第 217 行
------------------------------------------------------------
Build the desired set of partial tile prefixes.

We build a set of partial tile prefixes, which are prefixes of the vector
loop that have exactly VectorWidth iterations.

1. Drop all constraints involving the dimension that represents the
   vector loop.
2. Constrain the last dimension to get a set, which has exactly VectorWidth
   iterations.
3. Subtract loop domain from it, project out the vector loop dimension and
   get a set that contains prefixes, which do not have exactly VectorWidth
   iterations.
4. Project out the vector loop dimension of the set that was build on the
   first step and subtract the set built on the previous step to get the
   desired set of prefixes.

@param ScheduleRange A range of a map, which describes a prefix schedule
                     relation.

================================================================================

[345] 文件: include/ScheduleTreeTransform.h : 第 237 行
------------------------------------------------------------
Create an isl::union_set, which describes the isolate option based on
IsolateDomain.

@param IsolateDomain An isl::set whose @p OutDimsNum last dimensions should
                     belong to the current band node.
@param OutDimsNum    A number of dimensions that should belong to
                     the current band node.

================================================================================

[346] 文件: include/ScheduleTreeTransform.h : 第 246 行
------------------------------------------------------------
Create an isl::union_set, which describes the specified option for the
dimension of the current node.

@param Ctx    An isl::ctx, which is used to create the isl::union_set.
@param Option The name of the option.

================================================================================

[347] 文件: include/ScheduleTreeTransform.h : 第 253 行
------------------------------------------------------------
Tile a schedule node.

@param Node            The node to tile.
@param Identifier      An name that identifies this kind of tiling and
                       that is used to mark the tiled loops in the
                       generated AST.
@param TileSizes       A vector of tile sizes that should be used for
                       tiling.
@param DefaultTileSize A default tile size that is used for dimensions
                       that are not covered by the TileSizes vector.

================================================================================

[348] 文件: include/ScheduleTreeTransform.h : 第 266 行
------------------------------------------------------------
Tile a schedule node and unroll point loops.

@param Node            The node to register tile.
@param TileSizes       A vector of tile sizes that should be used for
                       tiling.
@param DefaultTileSize A default tile size that is used for dimensions

================================================================================

[349] 文件: include/ScheduleTreeTransform.h : 第 276 行
------------------------------------------------------------
Apply greedy fusion. That is, fuse any loop that is possible to be fused
top-down.

@param Sched  Sched tree to fuse all the loops in.
@param Deps   Validity constraints that must be preserved.

================================================================================

[350] 文件: include/MatmulOptimizer.h : 第 21 行
------------------------------------------------------------
Apply the BLIS matmul optimization pattern if possible.

Make the loops containing the matrix multiplication be the innermost
loops and apply the BLIS matmul optimization pattern. BLIS implements
gemm as three nested loops around a macro-kernel, plus two packing
routines. The macro-kernel is implemented in terms of two additional
loops around a micro-kernel. The micro-kernel is a loop around a rank-1
(i.e., outer product) update.

For a detailed description please see [1].

The order of the loops defines the data reused in the BLIS implementation
of gemm ([1]). In particular, elements of the matrix B, the second
operand of matrix multiplication, are reused between iterations of the
innermost loop. To keep the reused data in cache, only elements of matrix
A, the first operand of matrix multiplication, should be evicted during
an iteration of the innermost loop. To provide such a cache replacement
policy, elements of the matrix A can, in particular, be loaded first and,
consequently, be least-recently-used.

In our case matrices are stored in row-major order instead of
column-major order used in the BLIS implementation ([1]). It affects only
on the form of the BLIS micro kernel and the computation of its
parameters. In particular, reused elements of the matrix B are
successively multiplied by specific elements of the matrix A.

Refs.:
[1] - Analytical Modeling is Enough for High Performance BLIS
Tze Meng Low, Francisco D Igual, Tyler M Smith, Enrique S Quintana-Orti
Technical Report, 2014
http://www.cs.utexas.edu/users/flame/pubs/TOMS-BLIS-Analytical.pdf

@see ScheduleTreeOptimizer::createMicroKernel
@see ScheduleTreeOptimizer::createMacroKernel
@see getMicroKernelParams
@see getMacroKernelParams

TODO: Implement the packing transformation.

@param Node The node that contains a band to be optimized. The node
            is required to successfully pass
            ScheduleTreeOptimizer::isMatrMultPattern.
@param TTI  Target Transform Info.
@param D    The dependencies.

@returns    The transformed schedule or nullptr if the optimization
            cannot be applied.

================================================================================

[351] 文件: include/DependenceInfo.h : 第 31 行
------------------------------------------------------------
The accumulated dependence information for a SCoP.

The Dependences struct holds all dependence information we collect and
compute for one SCoP. It also offers an interface that allows users to
query only specific parts.

================================================================================

[352] 文件: include/DependenceInfo.h : 第 55 行
------------------------------------------------------------
The type of the dependences.

Reduction dependences are separated from RAW/WAW/WAR dependences because
we can ignore them during the scheduling. That's because the order
in which the reduction statements are executed does not matter. However,
if they are executed in parallel we need to take additional measures
(e.g, privatization) to ensure a correct result. The (reverse) transitive
closure of the reduction dependences are used to check for parallel
executed reduction statements during code generation. These dependences
connect all instances of a reduction with each other, they are therefore
cyclic and possibly "reversed".

================================================================================

[353] 文件: include/DependenceInfo.h : 第 85 行
------------------------------------------------------------
Get the dependences of type @p Kinds.

@param Kinds This integer defines the different kinds of dependences
             that will be returned. To return more than one kind, the
             different kinds are 'ored' together.

================================================================================

[354] 文件: include/DependenceInfo.h : 第 105 行
------------------------------------------------------------
Check if a partial schedule is parallel wrt to @p Deps.

@param Schedule       The subset of the schedule space that we want to
                      check.
@param Deps           The dependences @p Schedule needs to respect.
@param MinDistancePtr If not nullptr, the minimal dependence distance will
                      be returned at the address of that pointer

@return Returns true, if executing parallel the outermost dimension of
        @p Schedule is valid according to the dependences @p Deps.

================================================================================

[355] 文件: include/DependenceInfo.h : 第 119 行
------------------------------------------------------------
Check if a new schedule is valid.

@param S             The current SCoP.
@param NewSchedules  The new schedules

@return True if the new schedule is valid, false if it reverses
        dependences.

================================================================================

[356] 文件: include/DependenceInfo.h : 第 141 行
------------------------------------------------------------
Allow the DependenceInfo access to private members and methods.

To restrict access to the internal state, only the DependenceInfo class
is able to call or modify a Dependences struct.

================================================================================

[357] 文件: include/DependenceInfo.h : 第 201 行
------------------------------------------------------------
Return the dependence information for the current SCoP.

@param Level The granularity of dependence analysis result.

@return The dependence analysis result


================================================================================

[358] 文件: include/DependenceInfo.h : 第 212 行
------------------------------------------------------------
Invalidate the dependence information and recompute it when needed
again.
May be required when the underlying Scop was changed in a way that
would add new dependencies (e.g. between new statement instances
insierted into the SCoP) or intentionally breaks existing ones. It is
not required when updating the schedule that conforms the existing
dependencies.

================================================================================

[359] 文件: include/DependenceInfo.h : 第 242 行
------------------------------------------------------------
Return the dependence information for the current SCoP.

@param Level The granularity of dependence analysis result.

@return The dependence analysis result


================================================================================

[360] 文件: include/DependenceInfo.h : 第 253 行
------------------------------------------------------------
Invalidate the dependence information and recompute it when needed again.
May be required when the underlying Scop was changed in a way that would
add new dependencies (e.g. between new statement instances insierted into
the SCoP) or intentionally breaks existing ones. It is not required when
updating the schedule that conforms the existing dependencies.

================================================================================

[361] 文件: include/DependenceInfo.h : 第 293 行
------------------------------------------------------------
Return the dependence information for the given SCoP.

@param S     SCoP object.
@param Level The granularity of dependence analysis result.

@return The dependence analysis result


================================================================================

[362] 文件: include/ScopDetection.h : 第 154 行
------------------------------------------------------------
Map a base pointer to all access functions accessing it.

This map is indexed by the base pointer. Each element of the map
is a list of memory accesses that reference this base pointer.

================================================================================

[363] 文件: include/ScopDetection.h : 第 160 行
------------------------------------------------------------
The set of base pointers with non-affine accesses.

This set contains all base pointers and the locations where they are
used for memory accesses that can not be detected as affine accesses.

================================================================================

[364] 文件: include/ScopDetection.h : 第 230 行
------------------------------------------------------------
Check if @p S0 and @p S1 do contain multiple possibly aliasing pointers.

@param S0    A expression to check.
@param S1    Another expression to check or nullptr.
@param Scope The loop/scope the expressions are checked in.

@returns True, if multiple possibly aliasing pointers are used in @p S0
         (and @p S1 if given).

================================================================================

[365] 文件: include/ScopDetection.h : 第 240 行
------------------------------------------------------------
Add the region @p AR as over approximated sub-region in @p Context.

@param AR      The non-affine subregion.
@param Context The current detection context.

@returns True if the subregion can be over approximated, false otherwise.

================================================================================

[366] 文件: include/ScopDetection.h : 第 248 行
------------------------------------------------------------
Find for a given base pointer terms that hint towards dimension
       sizes of a multi-dimensional array.

@param Context      The current detection context.
@param BasePointer  A base pointer indicating the virtual array we are
                    interested in.

================================================================================

[367] 文件: include/ScopDetection.h : 第 258 行
------------------------------------------------------------
Check if the dimension size of a delinearized array is valid.

@param Context     The current detection context.
@param Sizes       The sizes of the different array dimensions.
@param BasePointer The base pointer we are interested in.
@param Scope       The location where @p BasePointer is being used.
@returns True if one or more array sizes could be derived - meaning: we
         see this array as multi-dimensional.

================================================================================

[368] 文件: include/ScopDetection.h : 第 270 行
------------------------------------------------------------
Derive access functions for a given base pointer.

@param Context     The current detection context.
@param Sizes       The sizes of the different array dimensions.
@param BasePointer The base pointer of all the array for which to compute
                   access functions.
@param Shape       The shape that describes the derived array sizes and
                   which should be filled with newly computed access
                   functions.
@returns True if a set of affine access functions could be derived.

================================================================================

[369] 文件: include/ScopDetection.h : 第 284 行
------------------------------------------------------------
Check if all accesses to a given BasePointer are affine.

@param Context     The current detection context.
@param BasePointer the base pointer we are interested in.
@param Scope       The location where @p BasePointer is being used.
@param True if consistent (multi-dimensional) array accesses could be
       derived for this array.

================================================================================

[370] 文件: include/ScopDetection.h : 第 313 行
------------------------------------------------------------
Check if a region has sufficient compute instructions.

This function checks if a region has a non-trivial number of instructions
in each loop. This can be used as an indicator whether a loop is worth
optimizing.

@param Context  The context of scop detection.
@param NumLoops The number of loops in the region.

@return True if region is has sufficient compute instructions,
        false otherwise.

================================================================================

[371] 文件: include/ScopDetection.h : 第 327 行
------------------------------------------------------------
Check if the unique affine loop might be amendable to distribution.

This function checks if the number of non-trivial blocks in the unique
affine loop in Context.CurRegion is at least two, thus if the loop might
be amendable to distribution.

@param Context  The context of scop detection.

@return True only if the affine loop might be amendable to distributable.

================================================================================

[372] 文件: include/ScopDetection.h : 第 338 行
------------------------------------------------------------
Check if a region is profitable to optimize.

Regions that are unlikely to expose interesting optimization opportunities
are called 'unprofitable' and may be skipped during scop detection.

@param Context The context of scop detection.

@return True if region is profitable to optimize, false otherwise.

================================================================================

[373] 文件: include/ScopDetection.h : 第 348 行
------------------------------------------------------------
Check if a region is a Scop.

@param Context The context of scop detection.

@return If we short-circuited early to not waste time on known-invalid
        SCoPs. Use Context.IsInvalid to determine whether the region is a
        valid SCoP.

================================================================================

[374] 文件: include/ScopDetection.h : 第 357 行
------------------------------------------------------------
Check if an intrinsic call can be part of a Scop.

@param II      The intrinsic call instruction to check.
@param Context The current detection context.

================================================================================

[375] 文件: include/ScopDetection.h : 第 363 行
------------------------------------------------------------
Check if a call instruction can be part of a Scop.

@param CI      The call instruction to check.
@param Context The current detection context.

================================================================================

[376] 文件: include/ScopDetection.h : 第 369 行
------------------------------------------------------------
Check if the given loads could be invariant and can be hoisted.

If true is returned the loads are added to the required invariant loads
contained in the @p Context.

@param RequiredILS The loads to check.
@param Context     The current detection context.

@return True if all loads can be assumed invariant.

================================================================================

[377] 文件: include/ScopDetection.h : 第 381 行
------------------------------------------------------------
Check if a value is invariant in the region Reg.

@param Val Value to check for invariance.
@param Reg The region to consider for the invariance of Val.
@param Ctx The current detection context.

@return True if the value represented by Val is invariant in the region
        identified by Reg.

================================================================================

[378] 文件: include/ScopDetection.h : 第 391 行
------------------------------------------------------------
Check if the memory access caused by @p Inst is valid.

@param Inst    The access instruction.
@param AF      The access function.
@param BP      The access base pointer.
@param Context The current detection context.

================================================================================

[379] 文件: include/ScopDetection.h : 第 400 行
------------------------------------------------------------
Check if a memory access can be part of a Scop.

@param Inst The instruction accessing the memory.
@param Context The context of scop detection.

================================================================================

[380] 文件: include/ScopDetection.h : 第 406 行
------------------------------------------------------------
Check if an instruction can be part of a Scop.

@param Inst The instruction to check.
@param Context The context of scop detection.

================================================================================

[381] 文件: include/ScopDetection.h : 第 412 行
------------------------------------------------------------
Check if the switch @p SI with condition @p Condition is valid.

@param BB           The block to check.
@param SI           The switch to check.
@param Condition    The switch condition.
@param IsLoopBranch Flag to indicate the branch is a loop exit/latch.
@param Context      The context of scop detection.

================================================================================

[382] 文件: include/ScopDetection.h : 第 422 行
------------------------------------------------------------
Check if the branch @p BI with condition @p Condition is valid.

@param BB           The block to check.
@param BI           The branch to check.
@param Condition    The branch condition.
@param IsLoopBranch Flag to indicate the branch is a loop exit/latch.
@param Context      The context of scop detection.

================================================================================

[383] 文件: include/ScopDetection.h : 第 432 行
------------------------------------------------------------
Check if the SCEV @p S is affine in the current @p Context.

This will also use a heuristic to decide if we want to require loads to be
invariant to make the expression affine or if we want to treat is as
non-affine.

@param S           The expression to be checked.
@param Scope       The loop nest in which @p S is used.
@param Context     The context of scop detection.

================================================================================

[384] 文件: include/ScopDetection.h : 第 443 行
------------------------------------------------------------
Check if the control flow in a basic block is valid.

This function checks if a certain basic block is terminated by a
Terminator instruction we can handle or, if this is not the case,
registers this basic block as the start of a non-affine region.

This function optionally allows unreachable statements.

@param BB               The BB to check the control flow.
@param IsLoopBranch     Flag to indicate the branch is a loop exit/latch.
 @param AllowUnreachable Allow unreachable statements.
@param Context          The context of scop detection.

================================================================================

[385] 文件: include/ScopDetection.h : 第 458 行
------------------------------------------------------------
Is a loop valid with respect to a given region.

@param L The loop to check.
@param Context The context of scop detection.

================================================================================

[386] 文件: include/ScopDetection.h : 第 464 行
------------------------------------------------------------
Count the number of loops and the maximal loop depth in @p L.

@param L The loop to check.
@param SE The scalar evolution analysis.
@param MinProfitableTrips The minimum number of trip counts from which
                          a loop is assumed to be profitable and
                          consequently is counted.
returns A tuple of number of loops and their maximal depth.

================================================================================

[387] 文件: include/ScopDetection.h : 第 481 行
------------------------------------------------------------
Can ISL compute the trip count of a loop.

@param L The loop to check.
@param Context The context of scop detection.

@return True if ISL can compute the trip count of the loop.

================================================================================

[388] 文件: include/ScopDetection.h : 第 492 行
------------------------------------------------------------
Check if a region is reducible or not.

@param Region The region to check.
@param DbgLoc Parameter to save the location of instruction that
              causes irregular control flow if the region is irreducible.

@return True if R is reducible, false otherwise.

================================================================================

[389] 文件: include/ScopDetection.h : 第 501 行
------------------------------------------------------------
Track diagnostics for invalid scops.

@param Context The context of scop detection.
@param Assert Throw an assert in verify mode or not.
@param Args Argument list that gets passed to the constructor of RR.

================================================================================

[390] 文件: include/ScopDetection.h : 第 524 行
------------------------------------------------------------
Is the region is the maximum region of a Scop?

@param R The Region to test if it is maximum.
@param Verify Rerun the scop detection to verify SCoP was not invalidated
              meanwhile. Do not use if the region's DetectionContect is
              referenced by a Scop that is still to be processed.

@return Return true if R is the maximum Region in a Scop, false otherwise.

================================================================================

[391] 文件: include/ScopDetection.h : 第 540 行
------------------------------------------------------------
Get a message why a region is invalid

@param R The region for which we get the error message

@return The error or "" if no error appeared.

================================================================================

[392] 文件: include/ScopDetection.h : 第 547 行
------------------------------------------------------------
@name Maximum Region In Scops Iterators

These iterators iterator over all maximum region in Scops of this
function.

================================================================================

[393] 文件: include/ScopDetection.h : 第 567 行
------------------------------------------------------------
Mark the function as invalid so we will not extract any scop from
       the function.

@param F The function to mark as invalid.

================================================================================

[394] 文件: include/ScopDetection.h : 第 582 行
------------------------------------------------------------
Count the number of loops and the maximal loop depth in @p R.

@param R The region to check
@param SE The scalar evolution analysis.
@param MinProfitableTrips The minimum number of trip counts from which
                          a loop is assumed to be profitable and
                          consequently is counted.
returns A tuple of number of loops and their maximal depth.

================================================================================

[395] 文件: include/ScopDetection.h : 第 594 行
------------------------------------------------------------
Check if the block is a error block.

A error block is currently any block that fulfills at least one of
the following conditions:

 - It is terminated by an unreachable instruction
 - It contains a call to a non-pure function that is not immediately
   dominated by a loop header and that does not dominate the region exit.
   This is a heuristic to pick only error blocks that are conditionally
   executed and can be assumed to be not executed at all without the
   domains being available.

@param BB The block to check.
@param R  The analyzed region.

@return True if the block is a error block, false otherwise.

================================================================================

[396] 文件: include/PolyhedralInfo.h : 第 8 行
------------------------------------------------------------

This file contains the declaration of the PolyhedralInfo class, which will
provide an interface to expose polyhedral analysis information of Polly.

This is work in progress. We will add more API's as and when deemed
required.

================================================================================

[397] 文件: include/PolyhedralInfo.h : 第 42 行
------------------------------------------------------------
Check if a given loop is parallel.

@param L The loop.

@return  Returns true, if loop is parallel false otherwise.

================================================================================

[398] 文件: include/PolyhedralInfo.h : 第 49 行
------------------------------------------------------------
Return the SCoP containing the @p L loop.

@param L The loop.

@return  Returns the SCoP containing the given loop.
         Returns null if the loop is not contained in any SCoP.

================================================================================

[399] 文件: include/PolyhedralInfo.h : 第 57 行
------------------------------------------------------------
Computes the partial schedule for the given @p L loop.

@param S The SCoP containing the given loop
@param L The loop.

@return  Returns the partial schedule for the given loop

================================================================================

[400] 文件: include/PolyhedralInfo.h : 第 80 行
------------------------------------------------------------
Check if a given loop is parallel or vectorizable.

@param L             The loop.
@param MinDepDistPtr If not nullptr, the minimal dependence distance will
                     be returned at the address of that pointer

@return  Returns true if loop is parallel or vectorizable, false
         otherwise.

================================================================================

[401] 文件: include/ZoneAlgo.h : 第 36 行
------------------------------------------------------------
Return only the mappings that map to known values.

@param UMap { [] -> ValInst[] }

@return { [] -> ValInst[] }

================================================================================

[402] 文件: include/ZoneAlgo.h : 第 49 行
------------------------------------------------------------
Hold a reference to the isl_ctx to avoid it being freed before we released
all of the isl objects.

This must be declared before any other member that holds an isl object.
This guarantees that the shared_ptr and its isl_ctx is destructed last,
after all other members free'd the isl objects they were holding.

================================================================================

[403] 文件: include/ZoneAlgo.h : 第 115 行
------------------------------------------------------------
List of PHIs that may transitively refer to themselves.

Computing them would require a polyhedral transitive closure operation,
for which isl may only return an approximation. For correctness, we always
require an exact result. Hence, we exclude such PHIs.

================================================================================

[404] 文件: include/ZoneAlgo.h : 第 127 行
------------------------------------------------------------
For computed PHIs, contains the ValInst they stand for.

To show an example, assume the following PHINode:

  Stmt:
    %phi = phi double [%val1, %bb1], [%val2, %bb2]

It's ValInst is:

  { [Stmt[i] -> phi[]] }

The value %phi will be either %val1 or %val2, depending on whether in
iteration i %bb1 or %bb2 has been executed before. In SCoPs, this can be
determined at compile-time, and the result stored in #NormalizeMap. For
the previous example, it could be:

  { [Stmt[i] -> phi[]] -> [Stmt[0] -> val1[]];
    [Stmt[i] -> phi[]] -> [Stmt[i] -> val2[]] : i > 0 }

Only ValInsts in #ComputedPHIs are present in this map. Other values are
assumed to represent themselves. This is to avoid adding lots of identity
entries to this map.

{ PHIValInst[] -> IncomingValInst[] }

================================================================================

[405] 文件: include/ZoneAlgo.h : 第 159 行
------------------------------------------------------------
Prepare the object before computing the zones of @p S.

@param PassName Name of the pass using this analysis.
@param S        The SCoP to process.
@param LI       LoopInfo analysis used to determine synthesizable values.

================================================================================

[406] 文件: include/ZoneAlgo.h : 第 167 行
------------------------------------------------------------
Find the array elements that violate the zone analysis assumptions.

What violates our assumptions:
- A load after a write of the same location; we assume that all reads
  occur before the writes.
- Two writes to the same location; we cannot model the order in which
  these occur.

Scalar reads implicitly always occur before other accesses therefore never
violate the first condition. There is also at most one write to a scalar,
satisfying the second condition.

@param Stmt                  The statement to be analyzed.
@param[out] IncompatibleElts Receives the elements that are not
                             zone-analysis compatible.
@param[out]                  AllElts receives all encountered elements.

================================================================================

[407] 文件: include/ZoneAlgo.h : 第 188 行
------------------------------------------------------------
Return the ValInst write by a (must-)write access. Returns the 'unknown'
ValInst if there is no single ValInst[] the array element written to will
have.

@return { ValInst[] }

================================================================================

[408] 文件: include/ZoneAlgo.h : 第 197 行
------------------------------------------------------------
For an llvm::Value defined in @p DefStmt, compute the RAW dependency for a
use in every instance of @p UseStmt.

@param UseStmt Statement a scalar is used in.
@param DefStmt Statement a scalar is defined in.

@return { DomainUse[] -> DomainDef[] }

================================================================================

[409] 文件: include/ZoneAlgo.h : 第 211 行
------------------------------------------------------------
For each 'execution' of a PHINode, get the incoming block that was
executed before.

For each PHI instance we can directly determine which was the incoming
block, and hence derive which value the PHI has.

@param SAI The ScopArrayInfo representing the PHI's storage.

@return { DomainPHIRead[] -> DomainPHIWrite[] }

================================================================================

[410] 文件: include/ZoneAlgo.h : 第 250 行
------------------------------------------------------------
Get a domain translation map from a (scalar) definition to the statement
where the definition is being moved to.

@p TargetStmt can also be seen at an llvm::Use of an llvm::Value in
@p DefStmt. In addition, we allow transitive uses:

DefStmt -> MiddleStmt -> TargetStmt

where an operand tree of instructions in DefStmt and MiddleStmt are to be
moved to TargetStmt. To be generally correct, we also need to know all the
intermediate statements. However, we make use of the fact that
ForwardOpTree currently does not support a move from a loop body across
its header such that only the first definition and the target statement
are relevant.

@param DefStmt    Statement from where a definition might be moved from.
@param TargetStmt Statement where the definition is potentially being
                  moved to (should contain a use of that definition).

@return { DomainDef[] -> DomainTarget[] }

================================================================================

[411] 文件: include/ZoneAlgo.h : 第 272 行
------------------------------------------------------------
Get the reaching definition of a scalar defined in @p Stmt.

Note that this does not depend on the llvm::Instruction, only on the
statement it is defined in. Therefore the same computation can be reused.

@param Stmt The statement in which a scalar is defined.

@return { Scatter[] -> DomainDef[] }

================================================================================

[412] 文件: include/ZoneAlgo.h : 第 282 行
------------------------------------------------------------
Get the reaching definition of a scalar defined in @p DefDomain.

@param DomainDef { DomainDef[] }
             The write statements to get the reaching definition for.

@return { Scatter[] -> DomainDef[] }

================================================================================

[413] 文件: include/ZoneAlgo.h : 第 290 行
------------------------------------------------------------
Create a statement-to-unknown value mapping.

@param Stmt The statement whose instances are mapped to unknown.

@return { Domain[] -> ValInst[] }

================================================================================

[414] 文件: include/ZoneAlgo.h : 第 306 行
------------------------------------------------------------
Create a mapping from a statement instance to the instance of an
llvm::Value that can be used in there.

Although LLVM IR uses single static assignment, llvm::Values can have
different contents in loops, when they get redefined in the last
iteration. This function tries to get the statement instance of the
previous definition, relative to a user.

Example:
for (int i = 0; i < N; i += 1) {
DEF:
   int v = A[i];
USE:
   use(v);
 }

The value instance used by statement instance USE[i] is DEF[i]. Hence,
makeValInst returns:

{ USE[i] -> [DEF[i] -> v[]] : 0 <= i < N }

@param Val       The value to get the instance of.
@param UserStmt  The statement that uses @p Val. Can be nullptr.
@param Scope     Loop the using instruction resides in.
@param IsCertain Pass true if the definition of @p Val is a
                 MUST_WRITE or false if the write is conditional.

@return { DomainUse[] -> ValInst[] }

================================================================================

[415] 文件: include/ZoneAlgo.h : 第 337 行
------------------------------------------------------------
Create and normalize a ValInst.

@see makeValInst
@see normalizeValInst
@see #NormalizedPHI

================================================================================

[416] 文件: include/ZoneAlgo.h : 第 353 行
------------------------------------------------------------
 Compute the normalization map that replaces PHIs by their incoming
 values.

@see #NormalizeMap

================================================================================

[417] 文件: include/ZoneAlgo.h : 第 367 行
------------------------------------------------------------
@{
Determine whether the argument does not map to any computed PHI. Those
should have been replaced by their incoming values.

@see #NormalizedPHI

================================================================================

[418] 文件: include/ZoneAlgo.h : 第 380 行
------------------------------------------------------------
A reaching definition zone is known to have the definition's written value
if the definition is a MUST_WRITE.

@return { [Element[] -> Zone[]] -> ValInst[] }

================================================================================

[419] 文件: include/ZoneAlgo.h : 第 386 行
------------------------------------------------------------
A reaching definition zone is known to be the same value as any load that
reads from that array element in that period.

@return { [Element[] -> Zone[]] -> ValInst[] }

================================================================================

[420] 文件: include/ZoneAlgo.h : 第 392 行
------------------------------------------------------------
Compute which value an array element stores at every instant.

@param FromWrite Use stores as source of information.
@param FromRead  Use loads as source of information.

@return { [Element[] -> Zone[]] -> ValInst[] }

================================================================================

[421] 文件: include/ZoneAlgo.h : 第 401 行
------------------------------------------------------------
Create a domain-to-unknown value mapping.

Value instances that do not represent a specific value are represented by an
unnamed tuple of 0 dimensions. Its meaning depends on the context. It can
either mean a specific but unknown value which cannot be represented by
other means. It conflicts with itself because those two unknown ValInsts may
have different concrete values at runtime.

The other meaning is an arbitrary or wildcard value that can be chosen
freely, like LLVM's undef. If matched with an unknown ValInst, there is no
conflict.

@param Domain { Domain[] }

@return { Domain[] -> ValInst[] }

================================================================================

[422] 文件: include/FlattenAlgo.h : 第 20 行
------------------------------------------------------------
Recursively flatten a schedule.

Reduce the number of scatter dimensions as much as possible without changing
the relative order of instances in a schedule. Ideally, this results in a
single scatter dimension, but it may not always be possible to combine
dimensions, eg. if a dimension is unbounded. In worst case, the original
schedule is returned.

Schedules with fewer dimensions may be easier to understand for humans, but
it should make no difference to the computer.

@param Schedule The input schedule.

@return The flattened schedule.

================================================================================

[423] 文件: include/ScopDetectionDiagnostic.h : 第 60 行
------------------------------------------------------------
Emit optimization remarks about the rejected regions to the user.

This emits the content of the reject log as optimization remarks.
Remember to at least track failures (-polly-detect-track-failures).
@param P The region delimiters (entry & exit) we emit remarks for.
@param Log The error log containing all messages being emitted as remark.

================================================================================

[424] 文件: include/ScopDetectionDiagnostic.h : 第 113 行
------------------------------------------------------------
Base class of all reject reasons found during Scop detection.

Subclasses of RejectReason should provide means to capture enough
diagnostic information to help clients figure out what and where something
went wrong in the Scop detection.

================================================================================

[425] 文件: include/ScopDetectionDiagnostic.h : 第 147 行
------------------------------------------------------------
Generate a message for the end-user describing this error.

The message provided has to be suitable for the end-user. So it should
not reference any LLVM internal data structures or terminology.
Ideally, the message helps the end-user to increase the size of the
regions amenable to Polly.

@return A short message representing this error.

================================================================================

[426] 文件: include/ScopDetectionDiagnostic.h : 第 191 行
------------------------------------------------------------
Base class for CFG related reject reasons.

Scop candidates that violate structural restrictions can be grouped under
this reject reason class.

================================================================================

[427] 文件: include/ScopDetectionDiagnostic.h : 第 306 行
------------------------------------------------------------
Base class for non-affine reject reasons.

Scop candidates that violate restrictions to affinity are reported under
this class.

================================================================================

[428] 文件: include/Simplify.h : 第 28 行
------------------------------------------------------------
Return a vector that contains MemoryAccesses in the order in
which they are executed.

The order is:
- Implicit reads (BlockGenerator::generateScalarLoads)
- Explicit reads and writes (BlockGenerator::generateArrayLoad,
  BlockGenerator::generateArrayStore)
  - In block statements, the accesses are in order in which their
    instructions are executed.
  - In region statements, that order of execution is not predictable at
    compile-time.
- Implicit writes (BlockGenerator::generateScalarStores)
  The order in which implicit writes are executed relative to each other is
  undefined.

================================================================================

[429] 文件: include/Simplify.h : 第 44 行
------------------------------------------------------------
Create a Simplify pass

@param CallNo Disambiguates this instance for when there are multiple
              instances of this pass in the pass manager. It is used only to
              keep the statistics apart and has no influence on the
              simplification itself.

@return The Simplify pass.

================================================================================

[430] 文件: include/Canonicalization.h : 第 22 行
------------------------------------------------------------
Schedule a set of canonicalization passes to prepare for Polly.

The set of optimization passes was partially taken/copied from the
set of default optimization passes in LLVM. It is used to bring the code
into a canonical form that simplifies the analysis and optimization passes
of Polly. The set of optimization passes scheduled here is probably not yet
optimal. TODO: Optimize the set of canonicalization passes.

================================================================================

[431] 文件: include/CodeGen/Utils.h : 第 32 行
------------------------------------------------------------
Execute a Scop conditionally wrt @p RTC.

In the CFG the optimized code of the Scop is generated next to the
original code. Both the new and the original version of the code remain
in the CFG. A branch statement decides which version is executed based on
the runtime value of @p RTC.

Before transformation:

                       bb0
                        |
                    orig_scop
                        |
                       bb1

After transformation:
                       bb0
                        |
                 polly.splitBlock
                    /       \.
                    |     startBlock
                    |        |
              orig_scop   new_scop
                    \      /
                     \    /
                       bb1 (joinBlock)

@param S   The Scop to execute conditionally.
@param P   A reference to the pass calling this function.
@param RTC The runtime condition checked before executing the new SCoP.

@return  An std::pair:
             - The first element is a BBPair of (StartBlock, EndBlock).
             - The second element is the BranchInst which conditionally
               branches to the SCoP based on the RTC.


================================================================================

[432] 文件: include/CodeGen/LoopGenerators.h : 第 48 行
------------------------------------------------------------
Create a scalar do/for-style loop.

@param LowerBound         The starting value of the induction variable.
@param UpperBound         The upper bound of the induction variable.
@param Stride             The value by which the induction variable
                          is incremented.

@param Builder            The builder used to create the loop.
@param P                  A pointer to the pass that uses this function.
                          It is used to update analysis information.
@param LI                 The loop info we need to update
@param DT                 The dominator tree we need to update
@param ExitBlock          The block the loop will exit to.
@param Predicate          The predicate used to generate the upper loop
                          bound.
@param Annotator          This function can (optionally) take
                          a ScopAnnotator which
                          annotates loops and alias information in the SCoP.
@param Parallel           If this loop should be marked parallel in
                          the Annotator.
@param UseGuard           Create a guard in front of the header to check if
                          the loop is executed at least once, otherwise just
                          assume it.
@param LoopVectDisabled   If the Loop vectorizer should be disabled for this
                          loop.

@return Value*    The newly created induction variable for this loop.

================================================================================

[433] 文件: include/CodeGen/LoopGenerators.h : 第 81 行
------------------------------------------------------------
Create a DebugLoc representing generated instructions.

The IR verifier requires !dbg metadata to be set in some situations. For
instance, if an (inlinable) function has debug info, all its call site must
have debug info as well.

================================================================================

[434] 文件: include/CodeGen/LoopGenerators.h : 第 88 行
------------------------------------------------------------
The ParallelLoopGenerator allows to create parallelized loops

To parallelize a loop, we perform the following steps:
  o  Generate a subfunction which will hold the loop body.
  o  Create a struct to hold all outer values needed in the loop body.
  o  Create calls to a runtime library to achieve the actual parallelism.
     These calls will spawn and join threads, define how the work (here the
     iterations) are distributed between them and make sure each has access
     to the struct holding all needed values.

At the moment we support only one parallel runtime, OpenMP.

If we parallelize the outer loop of the following loop nest,

  S0;
  for (int i = 0; i < N; i++)
    for (int j = 0; j < M; j++)
      S1(i, j);
  S2;

we will generate the following code (with different runtime function names):

  S0;
  auto *values = storeValuesIntoStruct();
  // Execute subfunction with multiple threads
  spawn_threads(subfunction, values);
  join_threads();
  S2;

 // This function is executed in parallel by different threads
  void subfunction(values) {
    while (auto *WorkItem = getWorkItem()) {
      int LB = WorkItem.begin();
      int UB = WorkItem.end();
      for (int i = LB; i < UB; i++)
        for (int j = 0; j < M; j++)
          S1(i, j);
    }
    cleanup_thread();
  }

================================================================================

[435] 文件: include/CodeGen/LoopGenerators.h : 第 140 行
------------------------------------------------------------
Create a parallel loop.

This function is the main function to automatically generate a parallel
loop with all its components.

@param LB        The lower bound for the loop we parallelize.
@param UB        The upper bound for the loop we parallelize.
@param Stride    The stride of the loop we parallelize.
@param Values    A set of LLVM-IR Values that should be available in
                 the new loop body.
@param VMap      A map to allow outside access to the new versions of
                 the values in @p Values.
@param LoopBody  A pointer to an iterator that is set to point to the
                 body of the created loop. It should be used to insert
                 instructions that form the actual loop body.

@return The newly created induction variable for this loop.

================================================================================

[436] 文件: include/CodeGen/LoopGenerators.h : 第 177 行
------------------------------------------------------------
Debug location for generated code without direct link to any specific
line.

We only set the DebugLoc where the IR Verifier requires us to. Otherwise,
absent debug location for optimized code should be fine.

================================================================================

[437] 文件: include/CodeGen/LoopGenerators.h : 第 191 行
------------------------------------------------------------
Create a struct for all @p Values and store them in there.

@param Values The values which should be stored in the struct.

@return The created struct.

================================================================================

[438] 文件: include/CodeGen/LoopGenerators.h : 第 198 行
------------------------------------------------------------
Extract all values from the @p Struct and construct the mapping.

@param Values The values which were stored in the struct.
@param Struct The struct holding all the values in @p Values.
@param VMap   A map to associate every element of @p Values with the
              new llvm value loaded from the @p Struct.

================================================================================

[439] 文件: include/CodeGen/LoopGenerators.h : 第 212 行
------------------------------------------------------------
Create the runtime library calls for spawn and join of the worker threads.
Additionally, places a call to the specified subfunction.

@param SubFn      The subfunction which holds the loop body.
@param SubFnParam The parameter for the subfunction (basically the struct
                  filled with the outside values).
@param LB         The lower bound for the loop we parallelize.
@param UB         The upper bound for the loop we parallelize.
@param Stride     The stride of the loop we parallelize.

================================================================================

[440] 文件: include/CodeGen/LoopGenerators.h : 第 224 行
------------------------------------------------------------
Prepare the definition of the parallel subfunction.
Creates the argument list and names them (as well as the subfunction).

@param F A pointer to the (parallel) subfunction's parent function.

@return The pointer to the (parallel) subfunction.

================================================================================

[441] 文件: include/CodeGen/LoopGenerators.h : 第 232 行
------------------------------------------------------------
Create the parallel subfunction.

@param Stride The induction variable increment.
@param Struct A struct holding all values in @p Values.
@param Values A set of LLVM-IR Values that should be available in
              the new loop body.
@param VMap   A map to allow outside access to the new versions of
              the values in @p Values.
@param SubFn  The newly created subfunction is returned here.

@return The newly created induction variable.

================================================================================

[442] 文件: include/CodeGen/LoopGeneratorsKMP.h : 第 40 行
------------------------------------------------------------
Convert the combination of given chunk size and scheduling type (which
might have been set via the command line) into the corresponding
scheduling type. This may result (e.g.) in a 'change' from
"static chunked" scheduling to "static non-chunked" (regarding the
provided and returned scheduling types).

@param ChunkSize    The chunk size, set via command line or its default.
@param Scheduling   The scheduling, set via command line or its default.

@return The corresponding OMPGeneralSchedulingType.

================================================================================

[443] 文件: include/CodeGen/LoopGeneratorsKMP.h : 第 61 行
------------------------------------------------------------
Create a runtime library call to spawn the worker threads.

@param SubFn      The subfunction which holds the loop body.
@param SubFnParam The parameter for the subfunction (basically the struct
                  filled with the outside values).
@param LB         The lower bound for the loop we parallelize.
@param UB         The upper bound for the loop we parallelize.
@param Stride     The stride of the loop we parallelize.

================================================================================

[444] 文件: include/CodeGen/LoopGeneratorsKMP.h : 第 86 行
------------------------------------------------------------
Create a runtime library call to request a number of threads.
Which will be used in the next OpenMP section (by the next fork).

@param GlobalThreadID   The global thread ID.
@param NumThreads       The number of threads to use.

================================================================================

[445] 文件: include/CodeGen/LoopGeneratorsKMP.h : 第 93 行
------------------------------------------------------------
Create a runtime library call to prepare the OpenMP runtime.
For dynamically scheduled loops, saving the loop arguments.

@param GlobalThreadID   The global thread ID.
@param LB               The loop's lower bound.
@param UB               The loop's upper bound.
@param Inc              The loop increment.
@param ChunkSize        The chunk size of the parallel loop.

================================================================================

[446] 文件: include/CodeGen/LoopGeneratorsKMP.h : 第 104 行
------------------------------------------------------------
Create a runtime library call to retrieve the next (dynamically)
allocated chunk of work for this thread.

@param GlobalThreadID   The global thread ID.
@param IsLastPtr        Pointer to a flag, which is set to 1 if this is
                        the last chunk of work, or 0 otherwise.
@param LBPtr            Pointer to the lower bound for the next chunk.
@param UBPtr            Pointer to the upper bound for the next chunk.
@param StridePtr        Pointer to the stride for the next chunk.

@return A Value which holds 1 if there is work to be done, 0 otherwise.

================================================================================

[447] 文件: include/CodeGen/LoopGeneratorsKMP.h : 第 118 行
------------------------------------------------------------
Create a runtime library call to prepare the OpenMP runtime.
For statically scheduled loops, saving the loop arguments.

@param GlobalThreadID   The global thread ID.
@param IsLastPtr        Pointer to a flag, which is set to 1 if this is
                        the last chunk of work, or 0 otherwise.
@param LBPtr            Pointer to the lower bound for the next chunk.
@param UBPtr            Pointer to the upper bound for the next chunk.
@param StridePtr        Pointer to the stride for the next chunk.
@param ChunkSize        The chunk size of the parallel loop.

================================================================================

[448] 文件: include/CodeGen/LoopGeneratorsKMP.h : 第 132 行
------------------------------------------------------------
Create a runtime library call to mark the end of
a statically scheduled loop.

@param GlobalThreadID   The global thread ID.

================================================================================

[449] 文件: include/CodeGen/BlockGenerators.h : 第 76 行
------------------------------------------------------------
Create a generator for basic blocks.

@param Builder     The LLVM-IR Builder used to generate the statement. The
                   code is generated at the location, the Builder points
                   to.
@param LI          The loop info for the current function
@param SE          The scalar evolution info for the current function
@param DT          The dominator tree of this function.
@param ScalarMap   Map from scalars to their demoted location.
@param EscapeMap   Map from scalars to their escape users and locations.
@param GlobalMap   A mapping from llvm::Values used in the original scop
                   region to a new set of llvm::Values. Each reference to
                   an original value appearing in this mapping is replaced
                   with the new value it is mapped to.
@param ExprBuilder An expression builder to generate new access functions.
@param StartBlock  The first basic block after the RTC.

================================================================================

[450] 文件: include/CodeGen/BlockGenerators.h : 第 97 行
------------------------------------------------------------
Copy the basic block.

This copies the entire basic block and updates references to old values
with references to new values, as defined by GlobalMap.

@param Stmt        The block statement to code generate.
@param LTS         A map from old loops to new induction variables as
                   SCEVs.
@param NewAccesses A map from memory access ids to new ast expressions,
                   which may contain new access expressions for certain
                   memory accesses.

================================================================================

[451] 文件: include/CodeGen/BlockGenerators.h : 第 111 行
------------------------------------------------------------
Remove a ScopArrayInfo's allocation from the ScalarMap.

This function allows to remove values from the ScalarMap. This is useful
if the corresponding alloca instruction will be deleted (or moved into
another module), as without removing these values the underlying
AssertingVH will trigger due to us still keeping reference to this
scalar.

@param Array The array for which the alloca was generated.

================================================================================

[452] 文件: include/CodeGen/BlockGenerators.h : 第 122 行
------------------------------------------------------------
Return the alloca for @p Access.

If no alloca was mapped for @p Access a new one is created.

@param Access    The memory access for which to generate the alloca.

@returns The alloca for @p Access or a replacement value taken from
         GlobalMap.

================================================================================

[453] 文件: include/CodeGen/BlockGenerators.h : 第 132 行
------------------------------------------------------------
Return the alloca for @p Array.

If no alloca was mapped for @p Array a new one is created.

@param Array The array for which to generate the alloca.

@returns The alloca for @p Array or a replacement value taken from
         GlobalMap.

================================================================================

[454] 文件: include/CodeGen/BlockGenerators.h : 第 142 行
------------------------------------------------------------
Finalize the code generation for the SCoP @p S.

This will initialize and finalize the scalar variables we demoted during
the code generation.

@see createScalarInitialization(Scop &)
@see createScalarFinalization(Region &)

================================================================================

[455] 文件: include/CodeGen/BlockGenerators.h : 第 173 行
------------------------------------------------------------
Map to resolve scalar dependences for PHI operands and scalars.

When translating code that contains scalar dependences as they result from
inter-block scalar dependences (including the use of data carrying PHI
nodes), we do not directly regenerate in-register SSA code, but instead
allocate some stack memory through which these scalar values are passed.
Only a later pass of -mem2reg will then (re)introduce in-register
computations.

To keep track of the memory location(s) used to store the data computed by
a given SSA instruction, we use the map 'ScalarMap'. ScalarMap maps a
given ScopArrayInfo to the junk of stack allocated memory, that is
used for code generation.

Up to two different ScopArrayInfo objects are associated with each
llvm::Value:

MemoryType::Value objects are used for normal scalar dependences that go
from a scalar definition to its use. Such dependences are lowered by
directly writing the value an instruction computes into the corresponding
chunk of memory and reading it back from this chunk of memory right before
every use of this original scalar value. The memory allocations for
MemoryType::Value objects end with '.s2a'.

MemoryType::PHI (and MemoryType::ExitPHI) objects are used to model PHI
nodes. For each PHI nodes we introduce, besides the Array of type
MemoryType::Value, a second chunk of memory into which we write at the end
of each basic block preceding the PHI instruction the value passed
through this basic block. At the place where the PHI node is executed, we
replace the PHI node with a load from the corresponding MemoryType::PHI
memory location. The memory allocations for MemoryType::PHI end with
'.phiops'.

Example:

                             Input C Code
                             ============

                S1:      x1 = ...
                         for (i=0...N) {
                S2:           x2 = phi(x1, add)
                S3:           add = x2 + 42;
                         }
                S4:      print(x1)
                         print(x2)
                         print(add)


       Unmodified IR                         IR After expansion
       =============                         ==================

S1:   x1 = ...                     S1:    x1 = ...
                                          x1.s2a = s1
                                          x2.phiops = s1
       |                                    |
       |   <--<--<--<--<                    |   <--<--<--<--<
       | /              \                   | /              \     .
       V V               \                  V V               \    .
S2:  x2 = phi (x1, add)   |        S2:    x2 = x2.phiops       |
                          |               x2.s2a = x2          |
                          |                                    |
S3:  add = x2 + 42        |        S3:    add = x2 + 42        |
                          |               add.s2a = add        |
                          |               x2.phiops = add      |
       | \               /                  | \               /
       |  \             /                   |  \             /
       |   >-->-->-->-->                    |   >-->-->-->-->
       V                                    V

                                   S4:    x1 = x1.s2a
S4:  ... = x1                             ... = x1
                                          x2 = x2.s2a
     ... = x2                             ... = x2
                                          add = add.s2a
     ... = add                            ... = add

     ScalarMap = { x1:Value -> x1.s2a, x2:Value -> x2.s2a,
                   add:Value -> add.s2a, x2:PHI -> x2.phiops }

 ??? Why does a PHI-node require two memory chunks ???

 One may wonder why a PHI node requires two memory chunks and not just
 all data is stored in a single location. The following example tries
 to store all data in .s2a and drops the .phiops location:

     S1:    x1 = ...
            x1.s2a = s1
            x2.s2a = s1             // use .s2a instead of .phiops
              |
              |   <--<--<--<--<
              | /              \    .
              V V               \   .
     S2:    x2 = x2.s2a          |  // value is same as above, but read
                                 |  // from .s2a
                                 |
            x2.s2a = x2          |  // store into .s2a as normal
                                 |
     S3:    add = x2 + 42        |
            add.s2a = add        |
            x2.s2a = add         |  // use s2a instead of .phiops
              | \               /   // !!! This is wrong, as x2.s2a now
              |   >-->-->-->-->     // contains add instead of x2.
              V

     S4:    x1 = x1.s2a
            ... = x1
            x2 = x2.s2a             // !!! We now read 'add' instead of
            ... = x2                // 'x2'
            add = add.s2a
            ... = add

 As visible in the example, the SSA value of the PHI node may still be
 needed _after_ the basic block, which could conceptually branch to the
 PHI node, has been run and has overwritten the PHI's old value. Hence, a
 single memory location is not enough to code-generate a PHI node.

Memory locations used for the special PHI node modeling.

================================================================================

[456] 文件: include/CodeGen/BlockGenerators.h : 第 310 行
------------------------------------------------------------
Copy the given basic block.

@param Stmt      The statement to code generate.
@param BB        The basic block to code generate.
@param BBMap     A mapping from old values to their new values in this
block.
@param LTS         A map from old loops to new induction variables as
                   SCEVs.
@param NewAccesses A map from memory access ids to new ast expressions,
                   which may contain new access expressions for certain
                   memory accesses.

@returns The copy of the basic block.

================================================================================

[457] 文件: include/CodeGen/BlockGenerators.h : 第 326 行
------------------------------------------------------------
Copy the given basic block.

@param Stmt      The statement to code generate.
@param BB        The basic block to code generate.
@param BBCopy    The new basic block to generate code in.
@param BBMap     A mapping from old values to their new values in this
block.
@param LTS         A map from old loops to new induction variables as
                   SCEVs.
@param NewAccesses A map from memory access ids to new ast expressions,
                   which may contain new access expressions for certain
                   memory accesses.

================================================================================

[458] 文件: include/CodeGen/BlockGenerators.h : 第 342 行
------------------------------------------------------------
Generate reload of scalars demoted to memory and needed by @p Stmt.

@param Stmt  The statement we generate code for.
@param LTS   A mapping from loops virtual canonical induction
             variable to their new values.
@param BBMap A mapping from old values to their new values in this block.
@param NewAccesses A map from memory access ids to new ast expressions.

================================================================================

[459] 文件: include/CodeGen/BlockGenerators.h : 第 353 行
------------------------------------------------------------
When statement tracing is enabled, build the print instructions for
printing the current statement instance.

The printed output looks like:

    Stmt1(0)

If printing of scalars is enabled, it also appends the value of each
scalar to the line:

    Stmt1(0) %i=1 %sum=5

@param Stmt  The statement we generate code for.
@param LTS   A mapping from loops virtual canonical induction
             variable to their new values.
@param BBMap A mapping from old values to their new values in this block.

================================================================================

[460] 文件: include/CodeGen/BlockGenerators.h : 第 372 行
------------------------------------------------------------
Generate instructions that compute whether one instance of @p Set is
executed.

@param Stmt      The statement we generate code for.
@param Subdomain A set in the space of @p Stmt's domain. Elements not in
                 @p Stmt's domain are ignored.

@return An expression of type i1, generated into the current builder
        position, that evaluates to 1 if the executed instance is part of
        @p Set.

================================================================================

[461] 文件: include/CodeGen/BlockGenerators.h : 第 384 行
------------------------------------------------------------
Generate code that executes in a subset of @p Stmt's domain.

@param Stmt        The statement we generate code for.
@param Subdomain   The condition for some code to be executed.
@param Subject     A name for the code that is executed
                   conditionally. Used to name new basic blocks and
                   instructions.
@param GenThenFunc Callback which generates the code to be executed
                   when the current executed instance is in @p Set. The
                   IRBuilder's position is moved to within the block that
                   executes conditionally for this callback.

================================================================================

[462] 文件: include/CodeGen/BlockGenerators.h : 第 399 行
------------------------------------------------------------
Generate the scalar stores for the given statement.

After the statement @p Stmt was copied all inner-SCoP scalar dependences
starting in @p Stmt (hence all scalar write accesses in @p Stmt) need to
be demoted to memory.

@param Stmt  The statement we generate code for.
@param LTS   A mapping from loops virtual canonical induction
             variable to their new values
             (for values recalculated in the new ScoP, but not
              within this basic block)
@param BBMap A mapping from old values to their new values in this block.
@param NewAccesses A map from memory access ids to new ast expressions.

================================================================================

[463] 文件: include/CodeGen/BlockGenerators.h : 第 416 行
------------------------------------------------------------
Handle users of @p Array outside the SCoP.

@param S         The current SCoP.
@param Inst      The ScopArrayInfo to handle.

================================================================================

[464] 文件: include/CodeGen/BlockGenerators.h : 第 422 行
------------------------------------------------------------
Find scalar statements that have outside users.

We register these scalar values to later update subsequent scalar uses of
these values to either use the newly computed value from within the scop
(if the scop was executed) or the unchanged original code (if the run-time
check failed).

@param S The scop for which to find the outside users.

================================================================================

[465] 文件: include/CodeGen/BlockGenerators.h : 第 437 行
------------------------------------------------------------
Create exit PHI node merges for PHI nodes with more than two edges
       from inside the scop.

For scops which have a PHI node in the exit block that has more than two
incoming edges from inside the scop region, we require some special
handling to understand which of the possible values will be passed to the
PHI node from inside the optimized version of the scop. To do so ScopInfo
models the possible incoming values as write accesses of the ScopStmts.

This function creates corresponding code to reload the computed outgoing
value from the stack slot it has been stored into and to pass it on to the
PHI node in the original exit block.

@param S The scop for which to generate the exiting PHI nodes.

================================================================================

[466] 文件: include/CodeGen/BlockGenerators.h : 第 453 行
------------------------------------------------------------
Promote the values of demoted scalars after the SCoP.

If a scalar value was used outside the SCoP we need to promote the value
stored in the memory cell allocated for that scalar and combine it with
the original value in the non-optimized SCoP.

================================================================================

[467] 文件: include/CodeGen/BlockGenerators.h : 第 460 行
------------------------------------------------------------
Try to synthesize a new value

Given an old value, we try to synthesize it in a new context from its
original SCEV expression. We start from the original SCEV expression,
then replace outdated parameter and loop references, and finally
expand it to code that computes this updated expression.

@param Stmt      The statement to code generate
@param Old       The old Value
@param BBMap     A mapping from old values to their new values
                 (for values recalculated within this basic block)
@param LTS       A mapping from loops virtual canonical induction
                 variable to their new values
                 (for values recalculated in the new ScoP, but not
                  within this basic block)
@param L         The loop that surrounded the instruction that referenced
                 this value in the original code. This loop is used to
                 evaluate the scalar evolution at the right scope.

@returns  o A newly synthesized value.
          o NULL, if synthesizing the value failed.

================================================================================

[468] 文件: include/CodeGen/BlockGenerators.h : 第 484 行
------------------------------------------------------------
Get the new version of a value.

Given an old value, we first check if a new version of this value is
available in the BBMap or GlobalMap. In case it is not and the value can
be recomputed using SCEV, we do so. If we can not recompute a value
using SCEV, but we understand that the value is constant within the scop,
we return the old value.  If the value can still not be derived, this
function will assert.

@param Stmt      The statement to code generate.
@param Old       The old Value.
@param BBMap     A mapping from old values to their new values
                 (for values recalculated within this basic block).
@param LTS       A mapping from loops virtual canonical induction
                 variable to their new values
                 (for values recalculated in the new ScoP, but not
                  within this basic block).
@param L         The loop that surrounded the instruction that referenced
                 this value in the original code. This loop is used to
                 evaluate the scalar evolution at the right scope.

@returns  o The old value, if it is still valid.
          o The new value, if available.
          o NULL, if no value is found.

================================================================================

[469] 文件: include/CodeGen/BlockGenerators.h : 第 517 行
------------------------------------------------------------
Generate the operand address
@param NewAccesses A map from memory access ids to new ast expressions,
                   which may contain new access expressions for certain
                   memory accesses.

================================================================================

[470] 文件: include/CodeGen/BlockGenerators.h : 第 525 行
------------------------------------------------------------
Generate the operand address.

@param Stmt         The statement to generate code for.
@param L            The innermost loop that surrounds the statement.
@param Pointer      If the access expression is not changed (ie. not found
                    in @p LTS), use this Pointer from the original code
                    instead.
@param BBMap        A mapping from old values to their new values.
@param LTS          A mapping from loops virtual canonical induction
                    variable to their new values.
@param NewAccesses  Ahead-of-time generated access expressions.
@param Id           Identifier of the MemoryAccess to generate.
@param ExpectedType The type the returned value should have.

@return The generated address.

================================================================================

[471] 文件: include/CodeGen/BlockGenerators.h : 第 545 行
------------------------------------------------------------
Generate the pointer value that is accesses by @p Access.

For write accesses, generate the target address. For read accesses,
generate the source address.
The access can be either an array access or a scalar access. In the first
case, the returned address will point to an element into that array. In
the scalar case, an alloca is used.
If a new AccessRelation is set for the MemoryAccess, the new relation will
be used.

@param Access      The access to generate a pointer for.
@param L           The innermost loop that surrounds the statement.
@param LTS         A mapping from loops virtual canonical induction
                   variable to their new values.
@param BBMap       A mapping from old values to their new values.
@param NewAccesses A map from memory access ids to new ast expressions.

@return The generated address.

================================================================================

[472] 文件: include/CodeGen/BlockGenerators.h : 第 580 行
------------------------------------------------------------
Copy a single PHI instruction.

The implementation in the BlockGenerator is trivial, however it allows
subclasses to handle PHIs different.

================================================================================

[473] 文件: include/CodeGen/BlockGenerators.h : 第 587 行
------------------------------------------------------------
Copy a single Instruction.

This copies a single Instruction and updates references to old values
with references to new values, as defined by GlobalMap and BBMap.

@param Stmt        The statement to code generate.
@param Inst        The instruction to copy.
@param BBMap       A mapping from old values to their new values
                   (for values recalculated within this basic block).
@param GlobalMap   A mapping from old values to their new values
                   (for values recalculated in the new ScoP, but not
                   within this basic block).
@param LTS         A mapping from loops virtual canonical induction
                   variable to their new values
                   (for values recalculated in the new ScoP, but not
                    within this basic block).
@param NewAccesses A map from memory access ids to new ast expressions,
                   which may contain new access expressions for certain
                   memory accesses.

================================================================================

[474] 文件: include/CodeGen/BlockGenerators.h : 第 614 行
------------------------------------------------------------
Remove dead instructions generated for BB

@param BB The basic block code for which code has been generated.
@param BBMap A local map from old to new instructions.

================================================================================

[475] 文件: include/CodeGen/BlockGenerators.h : 第 620 行
------------------------------------------------------------
Invalidate the scalar evolution expressions for a scop.

This function invalidates the scalar evolution results for all
instructions that are part of a given scop, and the loops
surrounding the users of merge blocks. This is necessary to ensure that
later scops do not obtain scalar evolution expressions that reference
values that earlier dominated the later scop, but have been moved in the
conditional part of an earlier scop and consequently do not any more
dominate the later scop.

@param S The scop to invalidate.

================================================================================

[476] 文件: include/CodeGen/BlockGenerators.h : 第 644 行
------------------------------------------------------------
Copy the region statement @p Stmt.

This copies the entire region represented by @p Stmt and updates
references to old values with references to new values, as defined by
GlobalMap.

@param Stmt      The statement to code generate.
@param LTS       A map from old loops to new induction variables as SCEVs.

================================================================================

[477] 文件: include/CodeGen/BlockGenerators.h : 第 678 行
------------------------------------------------------------
Add the new operand from the copy of @p IncomingBB to @p PHICopy.

PHI nodes, which may have (multiple) edges that enter from outside the
non-affine subregion and even from outside the scop, are code generated as
follows:

# Original

  Region: %A-> %exit
  NonAffine Stmt: %nonaffB -> %D (includes %nonaffB, %nonaffC)

    pre:
      %val = add i64 1, 1

    A:
     br label %nonaff

    nonaffB:
      %phi = phi i64 [%val, %A], [%valC, %nonAffC], [%valD, %D]
      %cmp = <nonaff>
      br i1 %cmp, label %C, label %nonaffC

    nonaffC:
      %valC = add i64 1, 1
      br i1 undef, label %D, label %nonaffB

    D:
      %valD = ...
      %exit_cond = <loopexit>
      br i1 %exit_cond, label %nonaffB, label %exit

    exit:
      ...

 - %start and %C enter from outside the non-affine region.
 - %nonaffC enters from within the non-affine region.

 # New

   polly.A:
      store i64 %val, i64* %phi.phiops
      br label %polly.nonaffA.entry

   polly.nonaffB.entry:
      %phi.phiops.reload = load i64, i64* %phi.phiops
      br label %nonaffB

   polly.nonaffB:
      %polly.phi = [%phi.phiops.reload, %nonaffB.entry],
                   [%p.valC, %polly.nonaffC]

   polly.nonaffC:
      %p.valC = add i64 1, 1
      br i1 undef, label %polly.D, label %polly.nonaffB

   polly.D:
       %p.valD = ...
       store i64 %p.valD, i64* %phi.phiops
       %p.exit_cond = <loopexit>
       br i1 %p.exit_cond, label %polly.nonaffB, label %exit

Values that enter the PHI from outside the non-affine region are stored
into the stack slot %phi.phiops by statements %polly.A and %polly.D and
reloaded in %polly.nonaffB.entry, a basic block generated before the
actual non-affine region.

When generating the PHI node of the non-affine region in %polly.nonaffB,
incoming edges from outside the region are combined into a single branch
from %polly.nonaffB.entry which has as incoming value the value reloaded
from the %phi.phiops stack slot. Incoming edges from within the region
refer to the copied instructions (%p.valC) and basic blocks
(%polly.nonaffC) of the non-affine region.

@param Stmt       The statement to code generate.
@param PHI        The original PHI we copy.
@param PHICopy    The copy of @p PHI.
@param IncomingBB An incoming block of @p PHI.
@param LTS        A map from old loops to new induction variables as
SCEVs.

================================================================================

[478] 文件: include/CodeGen/BlockGenerators.h : 第 760 行
------------------------------------------------------------
Create a PHI that combines the incoming values from all incoming blocks
that are in the subregion.

PHIs in the subregion's exit block can have incoming edges from within and
outside the subregion. This function combines the incoming values from
within the subregion to appear as if there is only one incoming edge from
the subregion (an additional exit block is created by RegionGenerator).
This is to avoid that a value is written to the .phiops location without
leaving the subregion because the exiting block as an edge back into the
subregion.

@param MA    The WRITE of MemoryKind::PHI/MemoryKind::ExitPHI for a PHI in
             the subregion's exit block.
@param LTS   Virtual induction variable mapping.
@param BBMap A mapping from old values to their new values in this block.
@param L     Loop surrounding this region statement.

@returns The constructed PHI node.

================================================================================

[479] 文件: include/CodeGen/BlockGenerators.h : 第 781 行
------------------------------------------------------------
@param Return the new value of a scalar write, creating a PHINode if
       necessary.

@param MA    A scalar WRITE MemoryAccess.
@param LTS   Virtual induction variable mapping.
@param BBMap A mapping from old values to their new values in this block.

@returns The effective value of @p MA's written value when leaving the
         subregion.
@see buildExitPHI

================================================================================

[480] 文件: include/CodeGen/BlockGenerators.h : 第 793 行
------------------------------------------------------------
Generate the scalar stores for the given statement.

After the statement @p Stmt was copied all inner-SCoP scalar dependences
starting in @p Stmt (hence all scalar write accesses in @p Stmt) need to
be demoted to memory.

@param Stmt  The statement we generate code for.
@param LTS   A mapping from loops virtual canonical induction variable to
             their new values (for values recalculated in the new ScoP,
             but not within this basic block)
@param BBMap A mapping from old values to their new values in this block.
@param LTS   A mapping from loops virtual canonical induction variable to
their new values.

================================================================================

[481] 文件: include/CodeGen/BlockGenerators.h : 第 810 行
------------------------------------------------------------
Copy a single PHI instruction.

This copies a single PHI instruction and updates references to old values
with references to new values, as defined by GlobalMap and BBMap.

@param Stmt      The statement to code generate.
@param PHI       The PHI instruction to copy.
@param BBMap     A mapping from old values to their new values
                 (for values recalculated within this basic block).
@param LTS       A map from old loops to new induction variables as SCEVs.

================================================================================

[482] 文件: include/CodeGen/IslExprBuilder.h : 第 34 行
------------------------------------------------------------
LLVM-IR generator for isl_ast_expr[essions]

This generator generates LLVM-IR that performs the computation described by
an isl_ast_expr[ession].

Example:

  An isl_ast_expr[ession] can look like this:

    (N + M) + 10

  The IslExprBuilder could create the following LLVM-IR:

    %tmp1 = add nsw i64 %N
    %tmp2 = add nsw i64 %tmp1, %M
    %tmp3 = add nsw i64 %tmp2, 10

The implementation of this class is mostly a mapping from isl_ast_expr
constructs to the corresponding LLVM-IR constructs.

The following decisions may need some explanation:

1) Which data-type to choose

isl_ast_expr[essions] are untyped expressions that assume arbitrary
precision integer computations. LLVM-IR instead has fixed size integers.
When lowering to LLVM-IR we need to chose both the size of the data type and
the sign of the operations we use.

At the moment, we hardcode i64 bit signed computations. Our experience has
shown that 64 bit are generally large enough for the loop bounds that appear
in the wild. Signed computations are needed, as loop bounds may become
negative.

It is possible to track overflows that occurred in the generated IR. See the
description of @see OverflowState for more information.

FIXME: Hardcoding sizes can cause issues:

  -  On embedded systems and especially for high-level-synthesis 64 bit
     computations are very costly.

  The right approach is to compute the minimal necessary bitwidth and
  signedness for each subexpression during in the isl AST generation and
  to use this information in our IslAstGenerator. Preliminary patches are
  available, but have not been committed yet.


================================================================================

[483] 文件: include/CodeGen/IslExprBuilder.h : 第 88 行
------------------------------------------------------------
A map from isl_ids to ScopArrayInfo objects.

This map is used to obtain ScopArrayInfo objects for isl_ids which do not
carry a ScopArrayInfo object in their user pointer. This is useful if the
construction of ScopArrayInfo objects happens only after references (e.g.
in an AST) to an isl_id are generated and the user pointer of the isl_id
can not be changed any more.

This is useful for external users who just use the IslExprBuilder for
code generation.

================================================================================

[484] 文件: include/CodeGen/IslExprBuilder.h : 第 105 行
------------------------------------------------------------
Construct an IslExprBuilder.

@param Builder     The IRBuilder used to construct the
                   isl_ast_expr[ession]. The insert location of this
                   IRBuilder defines WHERE the  corresponding LLVM-IR
                   is generated.
@param IDToValue   The isl_ast_expr[ession] may reference parameters or
                   variables (identified by an isl_id). The IDTOValue map
                   specifies the LLVM-IR Values that correspond to these
                   parameters and variables.
@param GlobalMap   A mapping from llvm::Values used in the original scop
                   region to a new set of llvm::Values.
@param DL          DataLayout for the current Module.
@param SE          ScalarEvolution analysis for the current function.
@param DT          DominatorTree analysis for the current function.
@param LI          LoopInfo analysis for the current function.
@param StartBlock The first basic block after the RTC.

================================================================================

[485] 文件: include/CodeGen/IslExprBuilder.h : 第 131 行
------------------------------------------------------------
Create LLVM-IR for an isl_ast_expr[ession].

@param Expr The ast expression for which we generate LLVM-IR.

@return The llvm::Value* containing the result of the computation.

================================================================================

[486] 文件: include/CodeGen/IslExprBuilder.h : 第 141 行
------------------------------------------------------------
Return the largest of two types.

@param T1 The first type.
@param T2 The second type.

@return The largest of the two types.

================================================================================

[487] 文件: include/CodeGen/IslExprBuilder.h : 第 149 行
------------------------------------------------------------
Return the type with which this expression should be computed.

The type needs to be large enough to hold all possible input and all
possible output values.

@param Expr The expression for which to find the type.
@return The type with which the expression should be computed.

================================================================================

[488] 文件: include/CodeGen/IslExprBuilder.h : 第 158 行
------------------------------------------------------------
Change if runtime overflows are tracked or not.

@param Enable Flag to enable/disable the tracking.

Note that this will reset the tracking state and that tracking is only
allowed if the last tracked expression dominates the current insert point.

================================================================================

[489] 文件: include/CodeGen/IslExprBuilder.h : 第 166 行
------------------------------------------------------------
Return the current overflow status or nullptr if it is not tracked.

@return A nullptr if tracking is disabled or otherwise an i1 that has the
        value of "0" if and only if no overflow happened since tracking
        was enabled.

================================================================================

[490] 文件: include/CodeGen/IslExprBuilder.h : 第 173 行
------------------------------------------------------------
Create LLVM-IR that computes the memory location of an access expression.

For a given isl_ast_expr[ession] of type isl_ast_op_access this function
creates IR that computes the address the access expression refers to.

@param Expr The ast expression of type isl_ast_op_access
            for which we generate LLVM-IR.

@return A pair of the llvm::Value* containing the result of the
        computation and the llvm::Type* it points to.

================================================================================

[491] 文件: include/CodeGen/IslExprBuilder.h : 第 186 行
------------------------------------------------------------
Check if an @p Expr contains integer constants larger than 64 bit.

@param Expr The expression to check.

@return True if the ast expression is larger than 64 bit.

================================================================================

[492] 文件: include/CodeGen/IslExprBuilder.h : 第 196 行
------------------------------------------------------------
Flag that will be set if an overflow occurred at runtime.

Note that this flag is by default a nullptr and if it is a nullptr
we will not record overflows but simply perform the computations.
The intended usage is as follows:
  - If overflows in [an] expression[s] should be tracked, call
    the setTrackOverflow(true) function.
  - Use create(...) for all expressions that should be checked.
  - Call getOverflowState() to get the value representing the current
    state of the overflow flag.
  - To stop tracking call setTrackOverflow(false).

================================================================================

[493] 文件: include/CodeGen/IslExprBuilder.h : 第 237 行
------------------------------------------------------------
Create a binary operation @p Opc and track overflows if requested.

@param OpC  The binary operation that should be performed [Add/Sub/Mul].
@param LHS  The left operand.
@param RHS  The right operand.
@param Name The (base) name of the new IR operations.

@return A value that represents the result of the binary operation.

================================================================================

[494] 文件: include/CodeGen/IslExprBuilder.h : 第 249 行
------------------------------------------------------------
Create an addition and track overflows if requested.

@param LHS  The left operand.
@param RHS  The right operand.
@param Name The (base) name of the new IR operations.

@return A value that represents the result of the addition.

================================================================================

[495] 文件: include/CodeGen/IslExprBuilder.h : 第 259 行
------------------------------------------------------------
Create a subtraction and track overflows if requested.

@param LHS  The left operand.
@param RHS  The right operand.
@param Name The (base) name of the new IR operations.

@return A value that represents the result of the subtraction.

================================================================================

[496] 文件: include/CodeGen/IslExprBuilder.h : 第 269 行
------------------------------------------------------------
Create a multiplication and track overflows if requested.

@param LHS  The left operand.
@param RHS  The right operand.
@param Name The (base) name of the new IR operations.

@return A value that represents the result of the multiplication.

================================================================================

[497] 文件: include/CodeGen/IRBuilder.h : 第 30 行
------------------------------------------------------------
Helper class to annotate newly generated SCoPs with metadata.

The annotations are twofold:
  1) Loops are stored in a stack-like structure in the order they are
     constructed and the LoopID metadata node is added to the backedge.
     Contained memory instructions and loop headers are annotated according
     to all parallel surrounding loops.
  2) The new SCoP is assumed alias free (either due to the result of
     AliasAnalysis queries or runtime alias checks). We annotate therefore
     all memory instruction with alias scopes to indicate that fact to
     later optimizations.
     These alias scopes live in a new alias domain only used in this SCoP.
     Each base pointer has its own alias scope and is annotated to not
     alias with any access to different base pointers.

================================================================================

[498] 文件: include/CodeGen/IRBuilder.h : 第 68 行
------------------------------------------------------------
Add alternative alias based pointers

When annotating instructions with alias scope metadata, the right metadata
is identified through the base pointer of the memory access. In some cases
(e.g. OpenMP code generation), the base pointer of the memory accesses is
not the original base pointer, but was changed when passing the original
base pointer over a function boundary. This function allows to provide a
map that maps from these new base pointers to the original base pointers
to allow the ScopAnnotator to still find the right alias scop annotations.

@param NewMap A map from new base pointers to original base pointers.

================================================================================

[499] 文件: include/CodeGen/IRBuilder.h : 第 119 行
------------------------------------------------------------
Add Polly specifics when running IRBuilder.

This is used to add additional items such as e.g. the llvm.loop.parallel
metadata.

================================================================================

[500] 文件: include/CodeGen/LoopGeneratorsGOMP.h : 第 35 行
------------------------------------------------------------
Create a runtime library call to spawn the worker threads.

@param SubFn      The subfunction which holds the loop body.
@param SubFnParam The parameter for the subfunction (basically the struct
                  filled with the outside values).
@param LB         The lower bound for the loop we parallelize.
@param UB         The upper bound for the loop we parallelize.
@param Stride     The stride of the loop we parallelize.

================================================================================

[501] 文件: include/CodeGen/LoopGeneratorsGOMP.h : 第 58 行
------------------------------------------------------------
Create a runtime library call to get the next work item.

@param LBPtr A pointer value to store the work item begin in.
@param UBPtr A pointer value to store the work item end in.

@returns A true value if the work item is not empty.

================================================================================

[502] 文件: include/CodeGen/LoopGeneratorsGOMP.h : 第 66 行
------------------------------------------------------------
Create a runtime library call to allow cleanup of the thread.

@note This function is called right before the thread will exit the
      subfunction and only if the runtime system depends on it.

================================================================================

[503] 文件: include/CodeGen/IslAst.h : 第 50 行
------------------------------------------------------------
Build run-time condition for scop.

@param S     The scop to build the condition for.
@param Build The isl_build object to use to build the condition.

@returns An ast expression that describes the necessary run-time check.

================================================================================

[504] 文件: include/CodeGen/IslAst.h : 第 117 行
------------------------------------------------------------
Get the run condition.

Only if the run condition evaluates at run-time to a non-zero value, the
assumptions that have been taken hold. If the run condition evaluates to
zero/false some assumptions do not hold and the original code needs to
be executed.

================================================================================

[505] 文件: include/CodeGen/IslAst.h : 第 127 行
------------------------------------------------------------
@name Extract information attached to an isl ast (for) node.

{
Get the complete payload attached to @p Node.

================================================================================

[506] 文件: include/CodeGen/IslNodeBuilder.h : 第 45 行
------------------------------------------------------------
Extract the out-of-scop values and SCEVs referenced from a ScopStmt.

This includes the SCEVUnknowns referenced by the SCEVs used in the
statement and the base pointers of the memory accesses. For scalar
statements we force the generation of alloca memory locations and list
these locations in the set of out-of-scop values as well.

We also collect an isl::space that includes all parameter dimensions
used in the statement's memory accesses, in case the ParamSpace pointer
is non-null.

@param Stmt             The statement for which to extract the information.
@param UserPtr          A void pointer that can be casted to a
                        SubtreeReferences structure.
@param CreateScalarRefs Should the result include allocas of scalar
                        references?

================================================================================

[507] 文件: include/CodeGen/IslNodeBuilder.h : 第 81 行
------------------------------------------------------------
Generate code that evaluates @p Condition at run-time.

This function is typically called to generate the LLVM-IR for the
run-time condition of the scop, that verifies that all the optimistic
assumptions we have taken during scop modeling and transformation
hold at run-time.

@param Condition The condition to evaluate

@result An llvm::Value that is true if the condition holds and false
        otherwise.

================================================================================

[508] 文件: include/CodeGen/IslNodeBuilder.h : 第 157 行
------------------------------------------------------------
The current iteration of out-of-scop loops

This map provides for a given loop a llvm::Value that contains the current
loop iteration.

================================================================================

[509] 文件: include/CodeGen/IslNodeBuilder.h : 第 171 行
------------------------------------------------------------
Generate code for a given SCEV*

This function generates code for a given SCEV expression. It generated
code is emitted at the end of the basic block our Builder currently
points to and the resulting value is returned.

@param Expr The expression to code generate.

================================================================================

[510] 文件: include/CodeGen/IslNodeBuilder.h : 第 180 行
------------------------------------------------------------
A set of Value -> Value remappings to apply when generating new code.

When generating new code for a ScopStmt this map is used to map certain
llvm::Values to new llvm::Values.

================================================================================

[511] 文件: include/CodeGen/IslNodeBuilder.h : 第 223 行
------------------------------------------------------------
Return non-negative number of iterations in case of the following form
of a loop and -1 otherwise.

for (i = 0; i <= NumIter; i++) {
  loop body;
}

NumIter is a non-negative integer value. Condition can have
isl_ast_op_lt type.

================================================================================

[512] 文件: include/CodeGen/IslNodeBuilder.h : 第 234 行
------------------------------------------------------------
Compute the values and loops referenced in this subtree.

This function looks at all ScopStmts scheduled below the provided For node
and finds the llvm::Value[s] and llvm::Loops[s] which are referenced but
not locally defined.

Values that can be synthesized or that are available as globals are
considered locally defined.

Loops that contain the scop or that are part of the scop are considered
locally defined. Loops that are before the scop, but do not contain the
scop itself are considered not locally defined.

@param For    The node defining the subtree.
@param Values A vector that will be filled with the Values referenced in
              this subtree.
@param Loops  A vector that will be filled with the Loops referenced in
              this subtree.

================================================================================

[513] 文件: include/CodeGen/IslNodeBuilder.h : 第 256 行
------------------------------------------------------------
Return the most up-to-date version of the llvm::Value for code generation.
@param Original The Value to check for an up to date version.
@returns A remapped `Value` from ValueMap, or `Original` if no mapping
         exists.
@see IslNodeBuilder::updateValues
@see IslNodeBuilder::ValueMap

================================================================================

[514] 文件: include/CodeGen/IslNodeBuilder.h : 第 264 行
------------------------------------------------------------
Generate code for a marker now.

For mark nodes with an unknown name, we just forward the code generation
to its child. This is currently the only behavior implemented, as there is
currently not special handling for marker nodes implemented.

@param Mark The node we generate code for.

================================================================================

[515] 文件: include/CodeGen/IslNodeBuilder.h : 第 286 行
------------------------------------------------------------
Preload the memory load access @p MA.

If @p MA is not always executed it will be conditionally loaded and
merged with undef from the same type. Hence, if @p MA is executed only
under condition C then the preload code will look like this:

MA_preload = undef;
if (C)
  MA_preload = load MA;
use MA_preload

================================================================================

[516] 文件: include/CodeGen/IslNodeBuilder.h : 第 299 行
------------------------------------------------------------
Preload the invariant access equivalence class @p IAClass

This function will preload the representing load from @p IAClass and
map all members of @p IAClass to that preloaded value, potentially casted
to the required type.

@returns False, iff a problem occurred and the load was not preloaded.

================================================================================

[517] 文件: include/CodeGen/IslNodeBuilder.h : 第 315 行
------------------------------------------------------------
Create new access functions for modified memory accesses.

In case the access function of one of the memory references in the Stmt
has been modified, we generate a new isl_ast_expr that reflects the
newly modified access function and return a map that maps from the
individual memory references in the statement (identified by their id)
to these newly generated ast expressions.

@param Stmt  The statement for which to (possibly) generate new access
             functions.
@param Node  The ast node corresponding to the statement for us to extract
             the local schedule from.
@return A new hash table that contains remappings from memory ids to new
        access expressions.

================================================================================

[518] 文件: include/CodeGen/IslNodeBuilder.h : 第 332 行
------------------------------------------------------------
Generate LLVM-IR that computes the values of the original induction
variables in function of the newly generated loop induction variables.

Example:

  // Original
  for i
    for j
      S(i)

  Schedule: [i,j] -> [i+j, j]

  // New
  for c0
    for c1
      S(c0 - c1, c1)

Assuming the original code consists of two loops which are
transformed according to a schedule [i,j] -> [c0=i+j,c1=j]. The resulting
ast models the original statement as a call expression where each argument
is an expression that computes the old induction variables from the new
ones, ordered such that the first argument computes the value of induction
variable that was outermost in the original code.

@param Expr The call expression that represents the statement.
@param Stmt The statement that is called.
@param LTS  The loop to SCEV map in which the mapping from the original
            loop to a SCEV representing the new loop iv is added. This
            mapping does not require an explicit induction variable.
            Instead, we think in terms of an implicit induction variable
            that counts the number of times a loop is executed. For each
            original loop this count, expressed in function of the new
            induction variables, is added to the LTS map.

================================================================================

[519] 文件: include/CodeGen/IslNodeBuilder.h : 第 375 行
------------------------------------------------------------
Get the schedule for a given AST node.

This information is used to reason about parallelism of loops or the
locality of memory accesses under a given schedule.

@param Node The node we want to obtain the schedule for.
@return Return an isl_union_map that maps from the statements executed
        below this ast node to the scheduling vectors used to enumerate
        them.


================================================================================

[520] 文件: include/CodeGen/IslNodeBuilder.h : 第 388 行
------------------------------------------------------------
Create code for a copy statement.

A copy statement is expected to have one read memory access and one write
memory access (in this very order). Data is loaded from the location
described by the read memory access and written to the location described
by the write memory access. @p NewAccesses contains for each access
the isl ast expression that describes the location accessed.

@param Stmt The copy statement that contains the accesses.
@param NewAccesses The hash table that contains remappings from memory
                   ids to new access expressions.

================================================================================

[521] 文件: include/CodeGen/IslNodeBuilder.h : 第 402 行
------------------------------------------------------------
Materialize a canonical loop induction variable for `L`, which is a loop
that is *not* present in the Scop.

Note that this is materialized at the point where the `Builder` is
currently pointing.
We also populate the `OutsideLoopIterations` map with `L`s SCEV to keep
track of the induction variable.
See [Code generation of induction variables of loops outside Scops]

================================================================================

[522] 文件: include/CodeGen/PerfMonitor.h : 第 18 行
------------------------------------------------------------
Create a new performance monitor.

@param S The scop for which to generate fine-grained performance
         monitoring information.
@param M The module for which to generate the performance monitor.

================================================================================

[523] 文件: include/CodeGen/PerfMonitor.h : 第 25 行
------------------------------------------------------------
Initialize the performance monitor.

Ensure that all global variables, functions, and callbacks needed to
manage the performance monitor are initialized and registered.

================================================================================

[524] 文件: include/CodeGen/PerfMonitor.h : 第 72 行
------------------------------------------------------------
Add Function @p to list of global constructors

If no global constructors are available in this current module, insert
a new list of global constructors containing @p Fn as only global
constructor. Otherwise, append @p Fn to the list of global constructors.

All functions listed as global constructors are executed before the
main() function is called.

@param Fn Function to add to global constructors

================================================================================

[525] 文件: include/CodeGen/PerfMonitor.h : 第 84 行
------------------------------------------------------------
Add global variables to module.

Insert a set of global variables that are used to track performance,
into the module (or obtain references to them if they already exist).

================================================================================

[526] 文件: include/CodeGen/PerfMonitor.h : 第 90 行
------------------------------------------------------------
Add per-scop tracking to module.

Insert the global variable which is used to track the number of cycles
this scop runs.

================================================================================

[527] 文件: include/CodeGen/PerfMonitor.h : 第 96 行
------------------------------------------------------------
Get a reference to the intrinsic "{ i64, i32 } @llvm.x86.rdtscp()".

The rdtscp function returns the current value of the processor's
time-stamp counter as well as the current CPU identifier. On modern x86
systems, the returned value is independent of the dynamic clock frequency
and consistent across multiple cores. It can consequently be used to get
accurate and low-overhead timing information. Even though the counter is
wrapping, it can be reliably used even for measuring longer time
intervals, as on a 1 GHz processor the counter only wraps every 545 years.

The RDTSCP instruction is "pseudo" serializing:

"“The RDTSCP instruction waits until all previous instructions have been
executed before reading the counter. However, subsequent instructions may
begin execution before the read operation is performed.”

To ensure that no later instructions are scheduled before the RDTSCP
instruction it is often recommended to schedule a cpuid call after the
RDTSCP instruction. We do not do this yet, trading some imprecision in
our timing for a reduced overhead in our timing.

@returns A reference to the declaration of @llvm.x86.rdtscp.

================================================================================

[528] 文件: include/CodeGen/PerfMonitor.h : 第 120 行
------------------------------------------------------------
Get a reference to "int atexit(void (*function)(void))" function.

This function allows to register function pointers that must be executed
when the program is terminated.

@returns A reference to @atexit().

================================================================================

[529] 文件: include/CodeGen/PerfMonitor.h : 第 128 行
------------------------------------------------------------
Create function "__polly_perf_final_reporting".

This function finalizes the performance measurements and prints the
results to stdout. It is expected to be registered with 'atexit()'.

================================================================================

[530] 文件: include/CodeGen/PerfMonitor.h : 第 134 行
------------------------------------------------------------
Append Scop reporting data to "__polly_perf_final_reporting".

This function appends the current scop (S)'s information to the final
printing function.

================================================================================

[531] 文件: include/CodeGen/CodeGeneration.h : 第 24 行
------------------------------------------------------------
Mark a basic block unreachable.

Marks the basic block @p Block unreachable by equipping it with an
UnreachableInst.

================================================================================

[532] 文件: include/CodeGen/RuntimeDebugBuilder.h : 第 26 行
------------------------------------------------------------
Insert function calls that print certain LLVM values at run time.

This class inserts libc function calls to print certain LLVM values at
run time.

================================================================================

[533] 文件: include/CodeGen/RuntimeDebugBuilder.h : 第 32 行
------------------------------------------------------------
Generate a constant string into the builder's llvm::Module which can be
passed to createCPUPrinter().

@param Builder The builder used to emit the printer calls.
@param Str     The string to be printed.

================================================================================

[534] 文件: include/CodeGen/RuntimeDebugBuilder.h : 第 42 行
------------------------------------------------------------
Return whether an llvm::Value of the type @p Ty is printable for
debugging.

That is, whether such a value can be passed to createGPUPrinter()
to be dumped as runtime.  If false is returned, those
functions will fail.

================================================================================

[535] 文件: include/CodeGen/RuntimeDebugBuilder.h : 第 50 行
------------------------------------------------------------
Print a set of LLVM-IR Values or StringRefs via printf

 This function emits a call to printf that will print the given arguments.
 It is useful for debugging CPU programs. All arguments given in this list
 will be automatically concatenated and the resulting string will be
 printed atomically. We also support ArrayRef arguments, which can be used
 to provide of id values.

 @param Builder The builder used to emit the printer calls.
 @param Args    The list of values to print.

================================================================================

[536] 文件: include/CodeGen/RuntimeDebugBuilder.h : 第 102 行
------------------------------------------------------------
Get a reference to the 'printf' function.

If the current module does not yet contain a reference to printf, we
insert a reference to it. Otherwise the existing reference is returned.

================================================================================

[537] 文件: include/CodeGen/RuntimeDebugBuilder.h : 第 108 行
------------------------------------------------------------
Call printf

@param Builder The builder used to insert the code.
@param Format  The format string.
@param Values  The set of values to print.

================================================================================

[538] 文件: include/Support/ScopLocation.h : 第 24 行
------------------------------------------------------------
Get the location of a region from the debug info.

@param R The region to get debug info for.
@param LineBegin The first line in the region.
@param LineEnd The last line in the region.
@param FileName The filename where the region was defined.

================================================================================

[539] 文件: include/Support/SCEVValidator.h : 第 23 行
------------------------------------------------------------
Find the loops referenced from a SCEV expression.

@param Expr The SCEV expression to scan for loops.
@param Loops A vector into which the found loops are inserted.

================================================================================

[540] 文件: include/Support/SCEVValidator.h : 第 30 行
------------------------------------------------------------
Find the values referenced by SCEVUnknowns in a given SCEV
expression.

@param Expr   The SCEV expression to scan for SCEVUnknowns.
@param SE     The ScalarEvolution analysis for this function.
@param Values A vector into which the found values are inserted.

================================================================================

[541] 文件: include/Support/SCEVValidator.h : 第 39 行
------------------------------------------------------------
Returns true when the SCEV contains references to instructions within the
region.

@param Expr The SCEV to analyze.
@param R The region in which we look for dependences.
@param Scope Location where the value is needed.
@param AllowLoops Whether loop recurrences outside the loop that are in the
                  region count as dependence.

================================================================================

[542] 文件: include/Support/SCEVValidator.h : 第 63 行
------------------------------------------------------------
Extract the constant factors from the multiplication @p M.

@param M  A potential SCEV multiplication.
@param SE The ScalarEvolution analysis to create new SCEVs.

@returns The constant factor in @p M and the rest of @p M.

================================================================================

[543] 文件: include/Support/SCEVValidator.h : 第 72 行
------------------------------------------------------------
Try to look through PHI nodes, where some incoming edges come from error
blocks.

In case a PHI node follows an error block we can assume that the incoming
value can only come from the node that is not an error block. As a result,
conditions that seemed non-affine before are now in fact affine.

================================================================================

[544] 文件: include/Support/SCEVValidator.h : 第 82 行
------------------------------------------------------------
Return a unique non-error block incoming value for @p PHI if available.

@param R The region to run our code on.
@param SD The ScopDetection

================================================================================

[545] 文件: include/Support/SCEVAffinator.h : 第 23 行
------------------------------------------------------------
The result type of the SCEVAffinator.

The first element of the pair is the isl representation of the SCEV, the
second is the domain under which it is __invalid__.

================================================================================

[546] 文件: include/Support/SCEVAffinator.h : 第 34 行
------------------------------------------------------------
Translate a SCEV to an isl::pw_aff.

@param E  he expression that is translated.
@param BB The block in which @p E is executed.

@returns The isl representation of the SCEV @p E in @p Domain.

================================================================================

[547] 文件: include/Support/SCEVAffinator.h : 第 80 行
------------------------------------------------------------
Compute the non-wrapping version of @p PWA for type @p ExprType.

@param PWA  The piece-wise affine function that might wrap.
@param Type The type of the SCEV that was translated to @p PWA.

@returns The expr @p PWA modulo the size constraints of @p ExprType.

================================================================================

[548] 文件: include/Support/SCEVAffinator.h : 第 88 行
------------------------------------------------------------
If @p Expr might cause an integer wrap record an assumption.

@param Expr The SCEV expression that might wrap.
@param PWAC The isl representation of @p Expr with the invalid domain.

@returns The isl representation @p PWAC with a possibly adjusted domain.

================================================================================

[549] 文件: include/Support/GICHelper.h : 第 25 行
------------------------------------------------------------
Translate an llvm::APInt to an isl_val.

Translate the bitsequence without sign information as provided by APInt into
a signed isl_val type. Depending on the value of @p IsSigned @p Int is
interpreted as unsigned value or as signed value in two's complement
representation.

Input IsSigned                 Output

    0        0           ->    0
    1        0           ->    1
   00        0           ->    0
   01        0           ->    1
   10        0           ->    2
   11        0           ->    3

    0        1           ->    0
    1        1           ->   -1
   00        1           ->    0
   01        1           ->    1
   10        1           ->   -2
   11        1           ->   -1

@param Ctx      The isl_ctx to create the isl_val in.
@param Int      The integer value to translate.
@param IsSigned If the APInt should be interpreted as signed or unsigned
                value.

@return The isl_val corresponding to @p Int.

================================================================================

[550] 文件: include/Support/GICHelper.h : 第 57 行
------------------------------------------------------------
Translate an llvm::APInt to an isl::val.

Translate the bitsequence without sign information as provided by APInt into
a signed isl::val type. Depending on the value of @p IsSigned @p Int is
interpreted as unsigned value or as signed value in two's complement
representation.

Input IsSigned                 Output

    0        0           ->    0
    1        0           ->    1
   00        0           ->    0
   01        0           ->    1
   10        0           ->    2
   11        0           ->    3

    0        1           ->    0
    1        1           ->   -1
   00        1           ->    0
   01        1           ->    1
   10        1           ->   -2
   11        1           ->   -1

@param Ctx      The isl_ctx to create the isl::val in.
@param Int      The integer value to translate.
@param IsSigned If the APInt should be interpreted as signed or unsigned
                value.

@return The isl::val corresponding to @p Int.

================================================================================

[551] 文件: include/Support/GICHelper.h : 第 91 行
------------------------------------------------------------
Translate isl_val to llvm::APInt.

This function can only be called on isl_val values which are integers.
Calling this function with a non-integral rational, NaN or infinity value
is not allowed.

As the input isl_val may be negative, the APInt that this function returns
must always be interpreted as signed two's complement value. The bitwidth of
the generated APInt is always the minimal bitwidth necessary to model the
provided integer when interpreting the bit pattern as signed value.

Some example conversions are:

  Input      Bits    Signed  Bitwidth
      0 ->      0         0         1
     -1 ->      1        -1         1
      1 ->     01         1         2
     -2 ->     10        -2         2
      2 ->    010         2         3
     -3 ->    101        -3         3
      3 ->    011         3         3
     -4 ->    100        -4         3
      4 ->   0100         4         4

@param Val The isl val to translate.

@return The APInt value corresponding to @p Val.

================================================================================

[552] 文件: include/Support/GICHelper.h : 第 120 行
------------------------------------------------------------
Translate isl::val to llvm::APInt.

This function can only be called on isl::val values which are integers.
Calling this function with a non-integral rational, NaN or infinity value
is not allowed.

As the input isl::val may be negative, the APInt that this function returns
must always be interpreted as signed two's complement value. The bitwidth of
the generated APInt is always the minimal bitwidth necessary to model the
provided integer when interpreting the bit pattern as signed value.

Some example conversions are:

  Input      Bits    Signed  Bitwidth
      0 ->      0         0         1
     -1 ->      1        -1         1
      1 ->     01         1         2
     -2 ->     10        -2         2
      2 ->    010         2         3
     -3 ->    101        -3         3
      3 ->    011         3         3
     -4 ->    100        -4         3
      4 ->   0100         4         4

@param Val The isl val to translate.

@return The APInt value corresponding to @p Val.

================================================================================

[553] 文件: include/Support/GICHelper.h : 第 298 行
------------------------------------------------------------
Combine Prefix, Val (or Number) and Suffix to an isl-compatible name.

In case @p UseInstructionNames is set, this function returns:

@p Prefix + "_" + @p Val->getName() + @p Suffix

otherwise

@p Prefix + to_string(Number) + @p Suffix

We ignore the value names by default, as they may change between release
and debug mode and can consequently not be used when aiming for reproducible
builds. However, for debugging named statements are often helpful, hence
we allow their optional use.

================================================================================

[554] 文件: include/Support/GICHelper.h : 第 317 行
------------------------------------------------------------
Combine Prefix, Name (or Number) and Suffix to an isl-compatible name.

In case @p UseInstructionNames is set, this function returns:

@p Prefix + "_" + Name + @p Suffix

otherwise

@p Prefix + to_string(Number) + @p Suffix

We ignore @p Name by default, as they may change between release
and debug mode and can consequently not be used when aiming for reproducible
builds. However, for debugging named statements are often helpful, hence
we allow their optional use.

================================================================================

[555] 文件: include/Support/GICHelper.h : 第 347 行
------------------------------------------------------------
Scope guard for code that allows arbitrary isl function to return an error
if the max-operations quota exceeds.

This allows to opt-in code sections that have known long executions times.
code not in a hot path can continue to assume that no unexpected error
occurs.

This is typically used inside a nested IslMaxOperationsGuard scope. The
IslMaxOperationsGuard defines the number of allowed base operations for some
code, IslQuotaScope defines where it is allowed to return an error result.

================================================================================

[556] 文件: include/Support/GICHelper.h : 第 412 行
------------------------------------------------------------
Scoped limit of ISL operations.

Limits the number of ISL operations during the lifetime of this object. The
idea is to use this as an RAII guard for the scope where the code is aware
that ISL can return errors even when all input is valid. After leaving the
scope, it will return to the error setting as it was before. That also means
that the error setting should not be changed while in that scope.

Such scopes are not allowed to be nested because the previous operations
counter cannot be reset to the previous state, or one that adds the
operations while being in the nested scope. Use therefore is only allowed
while currently a no operations-limit is active.

================================================================================

[557] 文件: include/Support/GICHelper.h : 第 426 行
------------------------------------------------------------
The ISL context to set the operations limit.

If set to nullptr, there is no need for any action at the end of the
scope.

================================================================================

[558] 文件: include/Support/GICHelper.h : 第 439 行
------------------------------------------------------------
Enter a max operations scope.

@param IslCtx      The ISL context to set the operations limit for.
@param LocalMaxOps Maximum number of operations allowed in the
                   scope. If set to zero, no operations limit is enforced.
@param AutoEnter   If true, automatically enters an IslQuotaScope such
                   that isl operations may return quota errors
                   immediately. If false, only starts the operations
                   counter, but isl does not return quota errors before
                   calling enter().

================================================================================

[559] 文件: include/Support/GICHelper.h : 第 472 行
------------------------------------------------------------
Enter a scope that can handle out-of-quota errors.

@param AllowReturnNull Whether the scoped code can handle out-of-quota
                       errors. If false, returns a dummy scope object that
                       does nothing.

================================================================================

[560] 文件: include/Support/DumpModulePass.h : 第 24 行
------------------------------------------------------------
Create a pass that prints the module into a file.

The meaning of @p Filename depends on @p IsSuffix. If IsSuffix==false, then
the module is written to the @p Filename. If it is true, the filename is
generated from the module's name, @p Filename with an '.ll' extension.

The intent of IsSuffix is to avoid the file being overwritten when
processing multiple modules and/or with multiple dump passes in the
pipeline.

================================================================================

[561] 文件: include/Support/ISLTools.h : 第 98 行
------------------------------------------------------------
Return the range elements that are lexicographically smaller.

@param Map    { Space[] -> Scatter[] }
@param Strict True for strictly lexicographically smaller elements (exclude
              same timepoints from the result).

@return { Space[] -> Scatter[] }
        A map to all timepoints that happen before the timepoints the input
        mapped to.

================================================================================

[562] 文件: include/Support/ISLTools.h : 第 112 行
------------------------------------------------------------
Return the range elements that are lexicographically larger.

@param Map    { Space[] -> Scatter[] }
@param Strict True for strictly lexicographically larger elements (exclude
              same timepoints from the result).

@return { Space[] -> Scatter[] }
        A map to all timepoints that happen after the timepoints the input
        map originally mapped to.

================================================================================

[563] 文件: include/Support/ISLTools.h : 第 126 行
------------------------------------------------------------
Construct a range of timepoints between two timepoints.

Example:
From := { A[] -> [0]; B[] -> [0] }
To   := {             B[] -> [10]; C[] -> [20] }

Result:
{ B[] -> [i] : 0 < i < 10 }

Note that A[] and C[] are not in the result because they do not have a start
or end timepoint. If a start (or end) timepoint is not unique, the first
(respectively last) is chosen.

@param From     { Space[] -> Scatter[] }
                Map to start timepoints.
@param To       { Space[] -> Scatter[] }
                Map to end timepoints.
@param InclFrom Whether to include the start timepoints in the result. In
                the example, this would add { B[] -> [0] }
@param InclTo   Whether to include the end timepoints in the result. In this
                example, this would add { B[] -> [10] }

@return { Space[] -> Scatter[] }
        A map for each domain element of timepoints between two extreme
        points, or nullptr if @p From or @p To is nullptr, or the isl max
        operations is exceeded.

================================================================================

[564] 文件: include/Support/ISLTools.h : 第 158 行
------------------------------------------------------------
If by construction a union map is known to contain only a single map, return
it.

This function combines isl_map_from_union_map() and
isl_union_map_extract_map(). isl_map_from_union_map() fails if the map is
empty because it does not know which space it would be in.
isl_union_map_extract_map() on the other hand does not check whether there
is (at most) one isl_map in the union, i.e. how it has been constructed is
probably wrong.

================================================================================

[565] 文件: include/Support/ISLTools.h : 第 169 行
------------------------------------------------------------
If by construction an isl_union_set is known to contain only a single
isl_set, return it.

This function combines isl_set_from_union_set() and
isl_union_set_extract_set(). isl_map_from_union_set() fails if the set is
empty because it does not know which space it would be in.
isl_union_set_extract_set() on the other hand does not check whether there
is (at most) one isl_set in the union, i.e. how it has been constructed is
probably wrong.

================================================================================

[566] 文件: include/Support/ISLTools.h : 第 180 行
------------------------------------------------------------
Determine how many dimensions the scatter space of @p Schedule has.

The schedule must not be empty and have equal number of dimensions of any
subspace it contains.

The implementation currently returns the maximum number of dimensions it
encounters, if different, and 0 if none is encountered. However, most other
code will most likely fail if one of these happen.

================================================================================

[567] 文件: include/Support/ISLTools.h : 第 190 行
------------------------------------------------------------
Return the scatter space of a @p Schedule.

This is basically the range space of the schedule map, but harder to
determine because it is an isl_union_map.

================================================================================

[568] 文件: include/Support/ISLTools.h : 第 196 行
------------------------------------------------------------
Construct an identity map for the given domain values.

@param USet           { Space[] }
                      The returned map's domain and range.
@param RestrictDomain If true, the returned map only maps elements contained
                      in @p Set and no other. If false, it returns an
                      overapproximation with the identity maps of any space
                      in @p Set, not just the elements in it.

@return { Space[] -> Space[] }
        A map that maps each value of @p Set to itself.

================================================================================

[569] 文件: include/Support/ISLTools.h : 第 209 行
------------------------------------------------------------
Construct an identity map for the given domain values.

There is no type resembling isl_union_space, hence we have to pass an
isl_union_set as the map's domain and range space.

@param USet           { Space[] }
                      The returned map's domain and range.
@param RestrictDomain If true, the returned map only maps elements contained
                      in @p USet and no other. If false, it returns an
                      overapproximation with the identity maps of any space
                      in @p USet, not just the elements in it.

@return { Space[] -> Space[] }
        A map that maps each value of @p USet to itself.

================================================================================

[570] 文件: include/Support/ISLTools.h : 第 225 行
------------------------------------------------------------
Reverse the nested map tuple in @p Map's domain.

@param Map { [Space1[] -> Space2[]] -> Space3[] }

@return { [Space2[] -> Space1[]] -> Space3[] }

================================================================================

[571] 文件: include/Support/ISLTools.h : 第 235 行
------------------------------------------------------------
Add a constant to one dimension of a set.

@param Map    The set to shift a dimension in.
@param Pos    The dimension to shift. If negative, the dimensions are
              counted from the end instead from the beginning. E.g. -1 is
              the last dimension in the tuple.
@param Amount The offset to add to the specified dimension.

@return The modified set.

================================================================================

[572] 文件: include/Support/ISLTools.h : 第 249 行
------------------------------------------------------------
Add a constant to one dimension of a map.

@param Map    The map to shift a dimension in.
@param Type   A tuple of @p Map which contains the dimension to shift.
@param Pos    The dimension to shift. If negative, the dimensions are
counted from the end instead from the beginning. Eg. -1 is the last
dimension in the tuple.
@param Amount The offset to add to the specified dimension.

@return The modified map.

================================================================================

[573] 文件: include/Support/ISLTools.h : 第 261 行
------------------------------------------------------------
Add a constant to one dimension of a each map in a union map.

@param UMap   The maps to shift a dimension in.
@param Type   The tuple which contains the dimension to shift.
@param Pos    The dimension to shift. If negative, the dimensions are
              counted from the ends of each map of union instead from their
              beginning. E.g. -1 is the last dimension of any map.
@param Amount The offset to add to the specified dimension.

@return The union of all modified maps.

================================================================================

[574] 文件: include/Support/ISLTools.h : 第 285 行
------------------------------------------------------------
Compute the reaching definition statement or the next overwrite for each
definition of an array element.

The reaching definition of an array element at a specific timepoint is the
statement instance that has written the current element's content.
Alternatively, this function determines for each timepoint and element which
write is going to overwrite an element at a future timepoint. This can be
seen as "reaching definition in reverse" where definitions are found in the
past.

For example:

Schedule := { Write[] -> [0]; Overwrite[] -> [10] }
Defs := { Write[] -> A[5]; Overwrite[] -> A[5] }

If index 5 of array A is written at timepoint 0 and 10, the resulting
reaching definitions are:

{ [A[5] -> [i]] -> Write[] : 0 < i < 10;
  [A[5] -> [i]] -> Overwrite[] : 10 < i }

Between timepoint 0 (Write[]) and timepoint 10 (Overwrite[]), the
content of A[5] is written by statement instance Write[] and after
timepoint 10 by Overwrite[]. Values not defined in the map have no known
definition. This includes the statement instance timepoints themselves,
because reads at those timepoints could either read the old or the new
value, defined only by the statement itself. But this can be changed by @p
InclPrevDef and @p InclNextDef. InclPrevDef=false and InclNextDef=true
returns a zone. Unless @p InclPrevDef and @p InclNextDef are both true,
there is only one unique definition per element and timepoint.

@param Schedule    { DomainWrite[] -> Scatter[] }
                   Schedule of (at least) all array writes. Instances not in
                   @p Writes are ignored.
@param Writes      { DomainWrite[] -> Element[] }
                   Elements written to by the statement instances.
@param Reverse     If true, look for definitions in the future. That is,
                   find the write that is overwrites the current value.
@param InclPrevDef Include the definition's timepoint to the set of
                   well-defined elements (any load at that timepoint happen
                   at the writes). In the example, enabling this option adds
                   {[A[5] -> [0]] -> Write[]; [A[5] -> [10]] -> Overwrite[]}
                   to the result.
@param InclNextDef Whether to assume that at the timepoint where an element
                   is overwritten, it still contains the old value (any load
                   at that timepoint would happen before the overwrite). In
                   this example, enabling this adds
                   { [A[] -> [10]] -> Write[] } to the result.

@return { [Element[] -> Scatter[]] -> DomainWrite[] }
        The reaching definitions or future overwrite as described above, or
        nullptr if either @p Schedule or @p Writes is nullptr, or the isl
        max operations count has exceeded.

================================================================================

[575] 文件: include/Support/ISLTools.h : 第 342 行
------------------------------------------------------------
Compute the timepoints where the contents of an array element are not used.

An element is unused at a timepoint when the element is overwritten in
the future, but it is not read in between. Another way to express this: the
time from when the element is written, to the most recent read before it, or
infinitely into the past if there is no read before. Such unused elements
can be overwritten by any value without changing the scop's semantics. An
example:

Schedule := { Read[] -> [0]; Write[] -> [10]; Def[] -> [20] }
Writes := { Write[] -> A[5]; Def[] -> A[6] }
Reads := { Read[] -> A[5] }

The result is:

{ A[5] -> [i] : 0 < i < 10;
  A[6] -> [i] : i < 20 }

That is, A[5] is unused between timepoint 0 (the read) and timepoint 10 (the
write). A[6] is unused before timepoint 20, but might be used after the
scop's execution (A[5] and any other A[i] as well). Use InclLastRead=false
and InclWrite=true to interpret the result as zone.

@param Schedule          { Domain[] -> Scatter[] }
                         The schedule of (at least) all statement instances
                         occurring in @p Writes or @p Reads. All other
                         instances are ignored.
@param Writes            { DomainWrite[] -> Element[] }
                         Elements written to by the statement instances.
@param Reads             { DomainRead[] -> Element[] }
                         Elements read from by the statement instances.
@param ReadEltInSameInst Whether a load reads the value from a write
                         that is scheduled at the same timepoint (Writes
                         happen before reads). Otherwise, loads use the
                         value of an element that it had before the
                         timepoint (Reads before writes). For example:
                         { Read[] -> [0]; Write[] -> [0] }
                         With ReadEltInSameInst=false it is assumed that the
                         read happens before the write, such that the
                         element is never unused, or just at timepoint 0,
                         depending on InclLastRead/InclWrite.
                         With ReadEltInSameInst=false it assumes that the
                         value just written is used. Anything before
                         timepoint 0 is considered unused.
@param InclLastRead      Whether a timepoint where an element is last read
                         counts as unused (the read happens at the beginning
                         of its timepoint, and nothing (else) can use it
                         during the timepoint). In the example, this option
                         adds { A[5] -> [0] } to the result.
@param InclWrite         Whether the timepoint where an element is written
                         itself counts as unused (the write happens at the
                         end of its timepoint; no (other) operations uses
                         the element during the timepoint). In this example,
                         this adds
                         { A[5] -> [10]; A[6] -> [20] } to the result.

@return { Element[] -> Scatter[] }
        The unused timepoints as defined above, or nullptr if either @p
        Schedule, @p Writes are @p Reads is nullptr, or the ISL max
        operations count is exceeded.

================================================================================

[576] 文件: include/Support/ISLTools.h : 第 407 行
------------------------------------------------------------
Convert a zone (range between timepoints) to timepoints.

A zone represents the time between (integer) timepoints, but not the
timepoints themselves. This function can be used to determine whether a
timepoint lies within a zone.

For instance, the range (1,3), representing the time between 1 and 3, is
represented by the zone

{ [i] : 1 < i <= 3 }

The set of timepoints that lie completely within this range is

{ [i] : 1 < i < 3 }

A typical use-case is the range in which a value written by a store is
available until it is overwritten by another value. If the write is at
timepoint 1 and its value is overwritten by another value at timepoint 3,
the value is available between those timepoints: timepoint 2 in this
example.


When InclStart is true, the range is interpreted left-inclusive, i.e. adds
the timepoint 1 to the result:

{ [i] : 1 <= i < 3 }

In the use-case mentioned above that means that the value written at
timepoint 1 is already available in timepoint 1 (write takes place before
any read of it even if executed at the same timepoint)

When InclEnd is true, the range is interpreted right-inclusive, i.e. adds
the timepoint 3 to the result:

{ [i] : 1 < i <= 3 }

In the use-case mentioned above that means that although the value is
overwritten in timepoint 3, the old value is still available at timepoint 3
(write takes place after any read even if executed at the same timepoint)

@param Zone      { Zone[] }
@param InclStart Include timepoints adjacent to the beginning of a zone.
@param InclEnd   Include timepoints adjacent to the ending of a zone.

@return { Scatter[] }

================================================================================

[577] 文件: include/Support/ISLTools.h : 第 465 行
------------------------------------------------------------
Distribute the domain to the tuples of a wrapped range map.

@param Map { Domain[] -> [Range1[] -> Range2[]] }

@return { [Domain[] -> Range1[]] -> [Domain[] -> Range2[]] }

================================================================================

[578] 文件: include/Support/ISLTools.h : 第 475 行
------------------------------------------------------------
Prepend a space to the tuples of a map.

@param UMap   { Domain[] -> Range[] }
@param Factor { Factor[] }

@return { [Factor[] -> Domain[]] -> [Factor[] -> Range[]] }

================================================================================

[579] 文件: include/Support/ISLTools.h : 第 483 行
------------------------------------------------------------
Apply a map to the 'middle' of another relation.

@param UMap { [DomainDomain[] -> DomainRange[]] -> Range[] }
@param Func { DomainRange[] -> NewDomainRange[] }

@return { [DomainDomain[] -> NewDomainRange[]] -> Range[] }

================================================================================

[580] 文件: include/Support/ISLTools.h : 第 491 行
------------------------------------------------------------
Intersect the range of @p Map with @p Range.

Since @p Map is an isl::map, the result will be a single space, even though
@p Range is an isl::union_set. This is the only difference to
isl::map::intersect_range and isl::union_map::interset_range.

@param Map   { Domain[] -> Range[] }
@param Range { Range[] }

@return { Domain[] -> Range[] }

================================================================================

[581] 文件: include/Support/ISLTools.h : 第 503 行
------------------------------------------------------------
Subtract the parameter space @p Params from @p Map.
This is akin to isl::map::intersect_params.

Example:
  subtractParams(
    { [i] -> [i] },
    [x] -> { : x < 0 }
  ) = [x] -> { [i] -> [i] : x >= 0 }

@param Map    Remove the conditions of @p Params from this map.
@param Params Parameter set to subtract.

@param The map with the parameter conditions removed.

================================================================================

[582] 文件: include/Support/ISLTools.h : 第 531 行
------------------------------------------------------------
Check that @p End is valid and return an iterator from @p Begin to @p End

Use case example:
  for (unsigned i : rangeIslSize(0, Map.domain_tuple_dim()))
    // do stuff

================================================================================

[583] 文件: include/Support/ISLTools.h : 第 538 行
------------------------------------------------------------
Dump a description of the argument to llvm::errs().

In contrast to isl's dump function, there are a few differences:
- Each polyhedron (pieces) is written on its own line.
- Spaces are sorted by structure. E.g. maps with same domain space are
  grouped. Isl sorts them according to the space's hash function.
- Pieces of the same space are sorted using their lower bound.
- A more compact to_str representation is used instead of Isl's dump
  functions that try to show the internal representation.

The goal is to get a better understandable representation that is also
useful to compare two sets. As all dump() functions, its intended use is to
be called in a debugger only.

isl_map_dump example:
[p_0, p_1, p_2] -> { Stmt0[i0] -> [o0, o1] : (o0 = i0 and o1 = 0 and i0 > 0
and i0 <= 5 - p_2) or (i0 = 0 and o0 = 0 and o1 = 0); Stmt3[i0] -> [o0, o1]
: (o0 = i0 and o1 = 3 and i0 > 0 and i0 <= 5 - p_2) or (i0 = 0 and o0 = 0
and o1 = 3); Stmt2[i0] -> [o0, o1] : (o0 = i0 and o1 = 1 and i0 >= 3 + p_0 -
p_1 and i0 > 0 and i0 <= 5 - p_2) or (o0 = i0 and o1 = 1 and i0 > 0 and i0
<= 5 - p_2 and i0 < p_0 - p_1) or (i0 = 0 and o0 = 0 and o1 = 1 and p_1 >= 3
+ p_0) or (i0 = 0 and o0 = 0 and o1 = 1 and p_1 < p_0) or (p_0 = 0 and i0 =
2 - p_1 and o0 = 2 - p_1 and o1 = 1 and p_2 <= 3 + p_1 and p_1 <= 1) or (p_1
= 1 + p_0 and i0 = 0 and o0 = 0 and o1 = 1) or (p_0 = 0 and p_1 = 2 and i0 =
0 and o0 = 0 and o1 = 1) or (p_0 = -1 and p_1 = -1 and i0 = 0 and o0 = 0 and
o1 = 1); Stmt1[i0] -> [o0, o1] : (p_0 = -1 and i0 = 1 - p_1 and o0 = 1 - p_1
and o1 = 2 and p_2 <= 4 + p_1 and p_1 <= 0) or (p_0 = 0 and i0 = -p_1 and o0
= -p_1 and o1 = 2 and p_2 <= 5 + p_1 and p_1 < 0) or (p_0 = -1 and p_1 = 1
and i0 = 0 and o0 = 0 and o1 = 2) or (p_0 = 0 and p_1 = 0 and i0 = 0 and o0
= 0 and o1 = 2) }

dumpPw example (same set):
[p_0, p_1, p_2] -> {
  Stmt0[0] -> [0, 0];
  Stmt0[i0] -> [i0, 0] : 0 < i0 <= 5 - p_2;
  Stmt1[0] -> [0, 2] : p_1 = 1 and p_0 = -1;
  Stmt1[0] -> [0, 2] : p_1 = 0 and p_0 = 0;
  Stmt1[1 - p_1] -> [1 - p_1, 2] : p_0 = -1 and p_1 <= 0 and p_2 <= 4 + p_1;
  Stmt1[-p_1] -> [-p_1, 2] : p_0 = 0 and p_1 < 0 and p_2 <= 5 + p_1;
  Stmt2[0] -> [0, 1] : p_1 >= 3 + p_0;
  Stmt2[0] -> [0, 1] : p_1 < p_0;
  Stmt2[0] -> [0, 1] : p_1 = 1 + p_0;
  Stmt2[0] -> [0, 1] : p_1 = 2 and p_0 = 0;
  Stmt2[0] -> [0, 1] : p_1 = -1 and p_0 = -1;
  Stmt2[i0] -> [i0, 1] : i0 >= 3 + p_0 - p_1 and 0 < i0 <= 5 - p_2;
  Stmt2[i0] -> [i0, 1] : 0 < i0 <= 5 - p_2 and i0 < p_0 - p_1;
  Stmt2[2 - p_1] -> [2 - p_1, 1] : p_0 = 0 and p_1 <= 1 and p_2 <= 3 + p_1;
  Stmt3[0] -> [0, 3];
  Stmt3[i0] -> [i0, 3] : 0 < i0 <= 5 - p_2
}
@{

================================================================================

[584] 文件: include/Support/ISLTools.h : 第 599 行
------------------------------------------------------------
Dump all points of the argument to llvm::errs().

Before being printed by dumpPw(), the argument's pieces are expanded to
contain only single points. If a dimension is unbounded, it keeps its
representation.

This is useful for debugging reduced cases where parameters are set to
constants to keep the example simple. Such sets can still contain
existential dimensions which makes the polyhedral hard to compare.

Example:
  { [MemRef_A[i0] -> [i1]] : (exists (e0 = floor((1 + i1)/3): i0 = 1 and 3e0
  <= i1 and 3e0 >= -1 + i1 and i1 >= 15 and i1 <= 25)) or (exists (e0 =
  floor((i1)/3): i0 = 0 and 3e0 < i1 and 3e0 >= -2 + i1 and i1 > 0 and i1 <=
  11)) }

dumpExpanded:
{
  [MemRef_A[0] ->[1]];
  [MemRef_A[0] ->[2]];
  [MemRef_A[0] ->[4]];
  [MemRef_A[0] ->[5]];
  [MemRef_A[0] ->[7]];
  [MemRef_A[0] ->[8]];
  [MemRef_A[0] ->[10]];
  [MemRef_A[0] ->[11]];
  [MemRef_A[1] ->[15]];
  [MemRef_A[1] ->[16]];
  [MemRef_A[1] ->[18]];
  [MemRef_A[1] ->[19]];
  [MemRef_A[1] ->[21]];
  [MemRef_A[1] ->[22]];
  [MemRef_A[1] ->[24]];
  [MemRef_A[1] ->[25]]
}
@{

================================================================================

[585] 文件: include/Support/VirtualInstruction.h : 第 22 行
------------------------------------------------------------
Determine the nature of a value's use within a statement.

These are not always representable by llvm::Use. For instance, scalar write
MemoryAccesses do use a value, but are not associated with an instruction's
argument.

Despite its name it is not tied to virtual instructions (although it works
fine with them), but to promote consistent handling of values used in
statements.

================================================================================

[586] 文件: include/Support/VirtualInstruction.h : 第 79 行
------------------------------------------------------------
If this is an inter-statement (or read-only) use, contains the
MemoryAccess that makes the value available in this statement. In case of
intra-statement uses, can contain a MemoryKind::Array access. In all other
cases, it is a nullptr.

================================================================================

[587] 文件: include/Support/VirtualInstruction.h : 第 91 行
------------------------------------------------------------
Get a VirtualUse for an llvm::Use.

@param S       The Scop object.
@param U       The llvm::Use the get information for.
@param LI      The LoopInfo analysis. Needed to determine whether the
               value is synthesizable.
@param Virtual Whether to ignore existing MemoryAccess.

@return The VirtualUse representing the same use as @p U.

================================================================================

[588] 文件: include/Support/VirtualInstruction.h : 第 102 行
------------------------------------------------------------
Get a VirtualUse for uses within statements.

It is assumed that the user is not a PHINode. Such uses are always
VirtualUse::Inter unless in a regions statement.

@param S         The Scop object.
@param UserStmt  The statement in which @p Val is used. Can be nullptr, in
                 which case it assumed that the statement has been
                 removed, which is only possible if no instruction in it
                 had side-effects or computes a value used by another
                 statement.
@param UserScope Loop scope in which the value is used. Needed to
                 determine whether the value is synthesizable.
@param Val       The value being used.
@param Virtual   Whether to use (and prioritize over instruction location)
                 information about MemoryAccesses.

@return A VirtualUse object that gives information about @p Val's use in
        @p UserStmt.

================================================================================

[589] 文件: include/Support/VirtualInstruction.h : 第 153 行
------------------------------------------------------------
Print a description of this object.

@param OS           Stream to print to.
@param Reproducible If true, ensures that the output is stable between
                    runs and is suitable to check in regression tests.
                    This excludes printing e.g. pointer values. If false,
                    the output should not be used for regression tests,
                    but may contain more information useful in debugger
                    sessions.

================================================================================

[590] 文件: include/Support/VirtualInstruction.h : 第 217 行
------------------------------------------------------------
This class represents a "virtual instruction", an instruction in a ScopStmt,
effectively a ScopStmt/Instruction-pair.

An instructions can be moved between statements (e.g. to avoid a scalar
dependency) and even can be contained in multiple statements (for instance,
to recompute a value instead of transferring it), hence 'virtual'. This
class is required to represent such instructions that are not in their
'physical' location anymore.

A statement can currently not contain the same instructions multiple times
(that is, from different loop iterations). Therefore, a
ScopStmt/Instruction-pair uniquely identifies a virtual instructions.
ScopStmt::getInstruction() can contain the same instruction multiple times,
but they necessarily compute the same value.

================================================================================

[591] 文件: include/Support/VirtualInstruction.h : 第 259 行
------------------------------------------------------------
Returns a list of virtual operands.

Virtual operands, like virtual instructions, need to encode the ScopStmt
they are in.

================================================================================

[592] 文件: include/Support/VirtualInstruction.h : 第 276 行
------------------------------------------------------------
Print a description of this object.

@param OS           Stream to print to.
@param Reproducible If true, ensures that the output is stable between
                    runs and is suitable for checks in regression tests.
                    This excludes printing e.g., pointer values. If false,
                    the output should not be used for regression tests,
                    but may contain more information useful in debugger
                    sessions.

================================================================================

[593] 文件: include/Support/VirtualInstruction.h : 第 297 行
------------------------------------------------------------
Find all reachable instructions and accesses.

@param S              The SCoP to find everything reachable in.
@param LI             LoopInfo required for analysis.
@param UsedInsts[out] Receives all reachable instructions.
@param UsedAccs[out]  Receives all reachable accesses.
@param OnlyLocal      If non-nullptr, activates local mode: The SCoP is
                      assumed to consist only of this statement and is
                      conservatively correct. Does not require walking the
                      whole SCoP.

================================================================================

[594] 文件: include/Support/ScopHelper.h : 第 82 行
------------------------------------------------------------
Record an assumption for later addition to the assumed context.

This function will add the assumption to the RecordedAssumptions. This
collection will be added (@see addAssumption) to the assumed context once
all parameters are known and the context is fully built.

@param RecordedAssumption container which keeps all recorded assumptions.
@param Kind The assumption kind describing the underlying cause.
@param Set  The relations between parameters that are assumed to hold.
@param Loc  The location in the source that caused this assumption.
@param Sign Enum to indicate if the assumptions in @p Set are positive
            (needed/assumptions) or negative (invalid/restrictions).
@param BB   The block in which this assumption was taken. If it is
            set, the domain of that block will be used to simplify the
            actual assumption in @p Set once it is added. This is useful
            if the assumption was created prior to the domain.
@param RTC  Does the assumption require a runtime check?

================================================================================

[595] 文件: include/Support/ScopHelper.h : 第 117 行
------------------------------------------------------------
Utility proxy to wrap the common members of LoadInst and StoreInst.

This works like the LLVM utility class CallSite, ie. it forwards all calls
to either a LoadInst, StoreInst, MemIntrinsic or MemTransferInst.
It is similar to LLVM's utility classes IntrinsicInst, MemIntrinsic,
MemTransferInst, etc. in that it offers a common interface, but does not act
as a fake base class.
It is similar to StringRef and ArrayRef in that it holds a pointer to the
referenced object and should be passed by-value as it is small enough.

This proxy can either represent a LoadInst instance, a StoreInst instance,
a MemIntrinsic instance (memset, memmove, memcpy), a CallInst instance or a
nullptr (only creatable using the default constructor); never an Instruction
that is neither of the above mentioned. When representing a nullptr, only
the following methods are defined:
isNull(), isInstruction(), isLoad(), isStore(), ..., isMemTransferInst(),
operator bool(), operator!()

The functions isa, cast, cast_or_null, dyn_cast are modeled to resemble
those from llvm/Support/Casting.h. Partial template function specialization
is currently not supported in C++ such that those cannot be used directly.
(llvm::isa could, but then llvm:cast etc. would not have the expected
behavior)

================================================================================

[596] 文件: include/Support/ScopHelper.h : 第 347 行
------------------------------------------------------------
Simplify the region to have a single unconditional entry edge and a
single exit edge.

Although this function allows DT and RI to be null, regions only work
properly if the DominatorTree (for Region::contains) and RegionInfo are kept
up-to-date.

@param R  The region to be simplified
@param DT DominatorTree to be updated.
@param LI LoopInfo to be updated.
@param RI RegionInfo to be updated.

================================================================================

[597] 文件: include/Support/ScopHelper.h : 第 361 行
------------------------------------------------------------
Split the entry block of a function to store the newly inserted
       allocations outside of all Scops.

@param EntryBlock The entry block of the current function.
@param P          The pass that currently running.


================================================================================

[598] 文件: include/Support/ScopHelper.h : 第 369 行
------------------------------------------------------------
Split the entry block of a function to store the newly inserted
       allocations outside of all Scops.

@param DT DominatorTree to be updated.
@param LI LoopInfo to be updated.
@param RI RegionInfo to be updated.

================================================================================

[599] 文件: include/Support/ScopHelper.h : 第 379 行
------------------------------------------------------------
Wrapper for SCEVExpander extended to all Polly features.

This wrapper will internally call the SCEVExpander but also makes sure that
all additional features not represented in SCEV (e.g., SDiv/SRem are not
black boxes but can be part of the function) will be expanded correctly.

The parameters are the same as for the creation of a SCEVExpander as well
as the call to SCEVExpander::expandCodeFor:

@param S     The current Scop.
@param SE    The Scalar Evolution pass used by @p S.
@param GenFn The function to generate code in. Can be the same as @p SE.
@param GenSE The Scalar Evolution pass for @p GenFn.
@param DL    The module data layout.
@param Name  The suffix added to the new instruction names.
@param E     The expression for which code is actually generated.
@param Ty    The type of the resulting code.
@param IP    The insertion point for the new code.
@param VMap  A remapping of values used in @p E.
@param LoopMap A remapping of loops used in @p E.
@param RTCBB The last block of the RTC. Used to insert loop-invariant
             instructions in rare cases.

================================================================================

[600] 文件: include/Support/ScopHelper.h : 第 408 行
------------------------------------------------------------
Return the condition for the terminator @p TI.

For unconditional branches the "i1 true" condition will be returned.

@param TI The terminator to get the condition from.

@return The condition of @p TI and nullptr if none could be extracted.

================================================================================

[601] 文件: include/Support/ScopHelper.h : 第 420 行
------------------------------------------------------------
Get the number of blocks in @p L.

The number of blocks in a loop are the number of basic blocks actually
belonging to the loop, as well as all single basic blocks that the loop
exits to and which terminate in an unreachable instruction. We do not
allow such basic blocks in the exit of a scop, hence they belong to the
scop and represent run-time conditions which we want to model and
subsequently speculate away.

@see getRegionNodeLoop for additional details.

================================================================================

[602] 文件: include/Support/ScopHelper.h : 第 438 行
------------------------------------------------------------
Check if @p LInst can be hoisted in @p R.

@param LInst The load to check.
@param R     The analyzed region.
@param LI    The loop info.
@param SE    The scalar evolution analysis.
@param DT    The dominator tree of the function.
@param KnownInvariantLoads The invariant load set.

@return True if @p LInst can be hoisted in @p R.

================================================================================

[603] 文件: include/Support/ScopHelper.h : 第 456 行
------------------------------------------------------------
Check whether a value an be synthesized by the code generator.

Some value will be recalculated only from information that is code generated
from the polyhedral representation. For such instructions we do not need to
ensure that their operands are available during code generation.

@param V The value to check.
@param S The current SCoP.
@param SE The scalar evolution database.
@param Scope Location where the value would by synthesized.
@return If the instruction I can be regenerated from its
        scalar evolution representation, return true,
        otherwise return false.

================================================================================

[604] 文件: include/Support/ScopHelper.h : 第 472 行
------------------------------------------------------------
Return the block in which a value is used.

For normal instructions, this is the instruction's parent block. For PHI
nodes, this is the incoming block of that use, because this is where the
operand must be defined (i.e. its definition dominates this block).
Non-instructions do not use operands at a specific point such that in this
case this function returns nullptr.

================================================================================

[605] 文件: include/Support/ScopHelper.h : 第 500 行
------------------------------------------------------------
Is the given instruction a call to a debug function?

A debug function can be used to insert output in Polly-optimized code which
normally does not allow function calls with side-effects. For instance, a
printf can be inserted to check whether a value still has the expected value
after Polly generated code:

    int sum = 0;
    for (int i = 0; i < 16; i+=1) {
      sum += i;
      printf("The value of sum at i=%d is %d\n", sum, i);
    }

================================================================================

[606] 文件: include/Support/ScopHelper.h : 第 519 行
------------------------------------------------------------
Find a property value in a LoopID.

Generally, a property MDNode has the format

  !{ !"Name", value }

In which case the value is returned.

If the property is just

  !{ !"Name" }

Then `nullptr` is set to mark the property is existing, but does not carry
any value. If the property does not exist, `std::nullopt` is returned.

================================================================================

[607] 文件: include/Support/ScopHelper.h : 第 544 行
------------------------------------------------------------
Does the loop's LoopID contain a 'llvm.loop.disable_heuristics' property?

This is equivalent to llvm::hasDisableAllTransformsHint(Loop*), but
including the LoopUtils.h header indirectly also declares llvm::MemoryAccess
which clashes with polly::MemoryAccess. Declaring this alias here avoid
having to include LoopUtils.h in other files.

================================================================================

[608] 文件: include/Support/ScopHelper.h : 第 555 行
------------------------------------------------------------
LoopID which stores the properties of the loop, such as transformations to
apply and the metadata of followup-loops.

Cannot be used to identify a loop. Two different loops can have the same
metadata.

================================================================================

[609] 文件: include/Support/ScopHelper.h : 第 562 行
------------------------------------------------------------
The LoopInfo reference for this loop.

Only loops from the original IR are represented by LoopInfo. Loops that
were generated by Polly are not tracked by LoopInfo.

================================================================================

[610] 文件: include/Support/ScopHelper.h : 第 569 行
------------------------------------------------------------
Get an isl::id representing a loop.

This takes the ownership of the BandAttr and will be free'd when the
returned isl::Id is free'd.

================================================================================

[611] 文件: include/Support/ScopHelper.h : 第 575 行
------------------------------------------------------------
Create an isl::id that identifies an original loop.

Return nullptr if the loop does not need a BandAttr (i.e. has no
properties);

This creates a BandAttr which must be unique per loop and therefore this
must not be called multiple times on the same loop as their id would be
different.

================================================================================

[612] 文件: include/Support/ISLOperators.h : 第 113 行
------------------------------------------------------------
Division

This division rounds towards zero. This follows the semantics of C/C++.

@{

================================================================================

[613] 文件: include/Support/ISLOperators.h : 第 147 行
------------------------------------------------------------
Remainder

This is the remainder of a division which rounds towards zero. This follows
the semantics of C/C++.

@{

================================================================================
